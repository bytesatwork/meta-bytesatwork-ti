From 474cdecd67f73b1b5af3c0dd146270749367aa4b Mon Sep 17 00:00:00 2001
From: Daniel Ammann <daniel.ammann@bytesatwork.ch>
Date: Tue, 10 Jul 2018 11:00:42 +0200
Subject: [PATCH] byteengine_m2: Add support for byteENGINE AM335x

---
 arch/arm/dts/am335x-bytedevkit-emmc.dts            |  34 ++
 arch/arm/dts/am335x-bytedevkit-nand.dts            |  22 ++
 arch/arm/dts/am335x-bytedevkit.dtsi                | 101 ++++++
 arch/arm/dts/am335x-byteengine.dtsi                | 265 +++++++++++++++
 arch/arm/mach-omap2/Kconfig                        |   1 +
 arch/arm/mach-omap2/am33xx/Kconfig                 |   9 +
 board/bytesatwork/byteengine_am335x/Kconfig        |  44 +++
 board/bytesatwork/byteengine_am335x/MAINTAINERS    |   7 +
 board/bytesatwork/byteengine_am335x/Makefile       |  21 ++
 board/bytesatwork/byteengine_am335x/board.c        | 149 +++++++++
 board/bytesatwork/byteengine_am335x/board.h        |  37 +++
 board/bytesatwork/byteengine_am335x/ddr_defs_baw.h |  59 ++++
 .../bytesatwork/byteengine_am335x/m2config/README  |  68 ++++
 .../byteengine_am335x/m2config/cmd_m2config.c      | 223 +++++++++++++
 .../byteengine_am335x/m2config/m2config.c          |  45 +++
 .../byteengine_am335x/m2config/m2config.h          |  79 +++++
 .../byteengine_am335x/m2config/m2config_builtin.c  |  15 +
 .../byteengine_am335x/m2config/m2config_builtin.h  |  21 ++
 .../byteengine_am335x/m2config/m2config_eeprom.c   | 301 +++++++++++++++++
 .../byteengine_am335x/m2config/m2config_eeprom.h   |  37 +++
 .../byteengine_am335x/m2config/m2config_get.c      |  45 +++
 .../byteengine_am335x/m2config/m2config_get.h      |  13 +
 board/bytesatwork/byteengine_am335x/mux.c          | 144 +++++++++
 board/bytesatwork/byteengine_am335x/ram.c          | 356 +++++++++++++++++++++
 board/bytesatwork/byteengine_am335x/u-boot.lds     | 131 ++++++++
 configs/am335x_bytedevkit_emmc_defconfig           |  65 ++++
 configs/am335x_bytedevkit_nand_defconfig           |  52 +++
 include/configs/byteengine_am335x.h                | 270 ++++++++++++++++
 28 files changed, 2614 insertions(+)
 create mode 100644 arch/arm/dts/am335x-bytedevkit-emmc.dts
 create mode 100644 arch/arm/dts/am335x-bytedevkit-nand.dts
 create mode 100644 arch/arm/dts/am335x-bytedevkit.dtsi
 create mode 100644 arch/arm/dts/am335x-byteengine.dtsi
 create mode 100644 board/bytesatwork/byteengine_am335x/Kconfig
 create mode 100644 board/bytesatwork/byteengine_am335x/MAINTAINERS
 create mode 100644 board/bytesatwork/byteengine_am335x/Makefile
 create mode 100644 board/bytesatwork/byteengine_am335x/board.c
 create mode 100644 board/bytesatwork/byteengine_am335x/board.h
 create mode 100644 board/bytesatwork/byteengine_am335x/ddr_defs_baw.h
 create mode 100644 board/bytesatwork/byteengine_am335x/m2config/README
 create mode 100644 board/bytesatwork/byteengine_am335x/m2config/cmd_m2config.c
 create mode 100644 board/bytesatwork/byteengine_am335x/m2config/m2config.c
 create mode 100644 board/bytesatwork/byteengine_am335x/m2config/m2config.h
 create mode 100644 board/bytesatwork/byteengine_am335x/m2config/m2config_builtin.c
 create mode 100644 board/bytesatwork/byteengine_am335x/m2config/m2config_builtin.h
 create mode 100644 board/bytesatwork/byteengine_am335x/m2config/m2config_eeprom.c
 create mode 100644 board/bytesatwork/byteengine_am335x/m2config/m2config_eeprom.h
 create mode 100644 board/bytesatwork/byteengine_am335x/m2config/m2config_get.c
 create mode 100644 board/bytesatwork/byteengine_am335x/m2config/m2config_get.h
 create mode 100644 board/bytesatwork/byteengine_am335x/mux.c
 create mode 100644 board/bytesatwork/byteengine_am335x/ram.c
 create mode 100644 board/bytesatwork/byteengine_am335x/u-boot.lds
 create mode 100644 configs/am335x_bytedevkit_emmc_defconfig
 create mode 100644 configs/am335x_bytedevkit_nand_defconfig
 create mode 100644 include/configs/byteengine_am335x.h

diff --git a/arch/arm/dts/am335x-bytedevkit-emmc.dts b/arch/arm/dts/am335x-bytedevkit-emmc.dts
new file mode 100644
index 0000000000..45fe239144
--- /dev/null
+++ b/arch/arm/dts/am335x-bytedevkit-emmc.dts
@@ -0,0 +1,34 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2018 bytes at work AG
+ *
+ * Based on am335x-evm.dts
+ *
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ */
+
+/dts-v1/;
+
+#include "am335x-byteengine.dtsi"
+#include "am335x-bytedevkit.dtsi"
+
+/ {
+	model = "bytesatwork byteDEVKIT with byteENGINE AM335x eMMC";
+	compatible = "bytesatwork,byteengine-am335x", "ti,am33xx";
+};
+
+&mmc2 {
+	status = "okay";
+};
+
+&spi0 {
+	status = "okay";
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "st,m25pe40", "jedec,spi-nor";
+		spi-max-frequency = <20000000>;
+		reg = <0>;
+	};
+};
diff --git a/arch/arm/dts/am335x-bytedevkit-nand.dts b/arch/arm/dts/am335x-bytedevkit-nand.dts
new file mode 100644
index 0000000000..4516117eb4
--- /dev/null
+++ b/arch/arm/dts/am335x-bytedevkit-nand.dts
@@ -0,0 +1,22 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2018 bytes at work AG
+ *
+ * Based on am335x-evm.dts
+ *
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ */
+
+/dts-v1/;
+
+#include "am335x-byteengine.dtsi"
+#include "am335x-bytedevkit.dtsi"
+
+/ {
+	model = "bytesatwork byteDEVKIT with byteENGINE AM335x NAND";
+	compatible = "bytesatwork,byteengine-am335x", "ti,am33xx";
+};
+
+&gpmc {
+	status = "okay";
+};
diff --git a/arch/arm/dts/am335x-bytedevkit.dtsi b/arch/arm/dts/am335x-bytedevkit.dtsi
new file mode 100644
index 0000000000..358d518fdb
--- /dev/null
+++ b/arch/arm/dts/am335x-bytedevkit.dtsi
@@ -0,0 +1,101 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2018 bytes at work AG
+ *
+ * Based on am335x-evm.dts
+ *
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ */
+
+/ {
+	chosen {
+		stdout-path = &uart0;
+	};
+};
+
+&am33xx_pinmux {
+	uart0_pins: pinmux_uart0_pins {
+		pinctrl-single,pins = <
+			0x170 (PIN_INPUT_PULLUP | MUX_MODE0)	/* uart0_rxd.uart0_rxd */
+			0x174 (PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* uart0_txd.uart0_txd */
+		>;
+	};
+
+	mmc1_pins: pinmux_mmc1_pins {
+		pinctrl-single,pins = <
+			0x0f0 (PIN_INPUT | MUX_MODE0)		/* mmc0_dat0.mmc0_dat0 */
+			0x0f4 (PIN_INPUT | MUX_MODE0)		/* mmc0_dat1.mmc0_dat1 */
+			0x0f8 (PIN_INPUT | MUX_MODE0)		/* mmc0_dat2.mmc0_dat2 */
+			0x0fc (PIN_INPUT | MUX_MODE0)		/* mmc0_dat3.mmc0_dat3 */
+			0x100 (PIN_INPUT | MUX_MODE0)		/* mmc0_clk.mmc0_clk */
+			0x104 (PIN_INPUT | MUX_MODE0)		/* mmc0_cmd.mmc0_cmd */
+			0x160 (PIN_INPUT_PULLUP | MUX_MODE7)	/* spi0_cs1.gpio0_6 */
+		>;
+	};
+
+	cpsw_default: cpsw_default {
+		pinctrl-single,pins = <
+			/* Slave 1 */
+			0x114 (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/* mii1_txen.rgmii1_tctl */
+			0x118 (PIN_INPUT_PULLDOWN | MUX_MODE2)	/* mii1_rxdv.rgmii1_rctl */
+			0x11c (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/* mii1_txd3.rgmii1_td3 */
+			0x120 (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/* mii1_txd2.rgmii1_td2 */
+			0x124 (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/* mii1_txd1.rgmii1_td1 */
+			0x128 (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/* mii1_txd0.rgmii1_td0 */
+			0x12c (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/* mii1_txclk.rgmii1_tclk */
+			0x130 (PIN_INPUT_PULLDOWN | MUX_MODE2)	/* mii1_rxclk.rgmii1_rclk */
+			0x134 (PIN_INPUT_PULLDOWN | MUX_MODE2)	/* mii1_rxd3.rgmii1_rd3 */
+			0x138 (PIN_INPUT_PULLDOWN | MUX_MODE2)	/* mii1_rxd2.rgmii1_rd2 */
+			0x13c (PIN_INPUT_PULLDOWN | MUX_MODE2)	/* mii1_rxd1.rgmii1_rd1 */
+			0x140 (PIN_INPUT_PULLDOWN | MUX_MODE2)	/* mii1_rxd0.rgmii1_rd0 */
+		>;
+	};
+
+	davinci_mdio_default: davinci_mdio_default {
+		pinctrl-single,pins = <
+			/* MDIO */
+			0x148 (PIN_INPUT_PULLUP | SLEWCTRL_FAST | MUX_MODE0)	/* mdio_data.mdio_data */
+			0x14c (PIN_OUTPUT_PULLUP | MUX_MODE0)			/* mdio_clk.mdio_clk */
+		>;
+	};
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+	status = "okay";
+
+	u-boot,dm-spl;
+};
+
+&mmc1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc1_pins>;
+	status = "okay";
+
+	vmmc-supply = <&vmmc_reg>;
+	bus-width = <0x4>;
+	cd-gpios = <&gpio0 6 GPIO_ACTIVE_LOW>;
+};
+
+&mac {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cpsw_default>;
+	status = "okay";
+};
+
+&davinci_mdio {
+	pinctrl-names = "default";
+	pinctrl-0 = <&davinci_mdio_default>;
+	status = "okay";
+};
+
+&cpsw_emac0 {
+	phy_id = <&davinci_mdio>, <0>;
+	phy-mode = "rgmii-txid";
+	ti,rx-internal-delay = <DP83867_RGMIIDCTL_2_25_NS>;
+	ti,tx-internal-delay = <DP83867_RGMIIDCTL_250_PS>;
+	ti,fifo-depth = <DP83867_PHYCR_FIFO_DEPTH_8_B_NIB>;
+	ti,min-output-impedance;
+	ti,dp83867-rxctrl-strap-quirk;
+};
diff --git a/arch/arm/dts/am335x-byteengine.dtsi b/arch/arm/dts/am335x-byteengine.dtsi
new file mode 100644
index 0000000000..c16b80988d
--- /dev/null
+++ b/arch/arm/dts/am335x-byteengine.dtsi
@@ -0,0 +1,265 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2018 bytes at work AG
+ *
+ * Based on am335x-evm.dts
+ *
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ */
+
+#include "am33xx.dtsi"
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/net/ti-dp83867.h>
+
+/ {
+	compatible = "bytesatwork,byteengine-am335x", "ti,am33xx";
+
+	chosen {
+		tick-timer = &timer2;
+	};
+
+	cpus {
+		cpu@0 {
+			cpu0-supply = <&vdd1_reg>;
+		};
+	};
+
+	memory {
+		device_type = "memory";
+	};
+
+	vbat: fixedregulator@0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vbat";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-boot-on;
+	};
+};
+
+&am33xx_pinmux {
+	pinctrl-names = "default";
+	pinctrl-0 = <&clkout2_pin>;
+
+	i2c0_pins: pinmux_i2c0_pins {
+		pinctrl-single,pins = <
+			0x188 (PIN_INPUT_PULLUP | MUX_MODE0)	/* i2c0_sda.i2c0_sda */
+			0x18c (PIN_INPUT_PULLUP | MUX_MODE0)	/* i2c0_scl.i2c0_scl */
+		>;
+	};
+
+	clkout2_pin: pinmux_clkout2_pin {
+		pinctrl-single,pins = <
+			0x1b4 (PIN_OUTPUT_PULLDOWN | MUX_MODE3)	/* xdma_event_intr1.clkout2 */
+		>;
+	};
+
+	nandflash_pins_s0: nandflash_pins_s0 {
+		pinctrl-single,pins = <
+			0x0 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_ad0.gpmc_ad0 */
+			0x4 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_ad1.gpmc_ad1 */
+			0x8 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_ad2.gpmc_ad2 */
+			0xc (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_ad3.gpmc_ad3 */
+			0x10 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_ad4.gpmc_ad4 */
+			0x14 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_ad5.gpmc_ad5 */
+			0x18 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_ad6.gpmc_ad6 */
+			0x1c (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_ad7.gpmc_ad7 */
+			0x70 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_wait0.gpmc_wait0 */
+			0x74 (PIN_INPUT_PULLUP | MUX_MODE7)	/* gpmc_wpn.gpio0_30 */
+			0x7c (PIN_OUTPUT | MUX_MODE0)		/* gpmc_csn0.gpmc_csn0  */
+			0x90 (PIN_OUTPUT | MUX_MODE0)		/* gpmc_advn_ale.gpmc_advn_ale */
+			0x94 (PIN_OUTPUT | MUX_MODE0)		/* gpmc_oen_ren.gpmc_oen_ren */
+			0x98 (PIN_OUTPUT | MUX_MODE0)		/* gpmc_wen.gpmc_wen */
+			0x9c (PIN_OUTPUT | MUX_MODE0)		/* gpmc_be0n_cle.gpmc_be0n_cle */
+		>;
+	};
+
+	mmc2_pins: pinmux_mmc2_pins {
+		pinctrl-single,pins = <
+			0x80 (PIN_INPUT_PULLUP | MUX_MODE2) /* gpmc_csn1.mmc1_clk */
+			0x84 (PIN_INPUT_PULLUP | MUX_MODE2) /* gpmc_csn2.mmc1_cmd */
+			0x00 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad0.mmc1_dat0 */
+			0x04 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad1.mmc1_dat1 */
+			0x08 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad2.mmc1_dat2 */
+			0x0c (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad3.mmc1_dat3 */
+			0x10 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad4.mmc1_dat4 */
+			0x14 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad5.mmc1_dat5 */
+			0x18 (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad6.mmc1_dat6 */
+			0x1c (PIN_INPUT_PULLUP | MUX_MODE1) /* gpmc_ad7.mmc1_dat7 */
+		>;
+	};
+
+	spi0_pins: pinmux_spi0_pins {
+		pinctrl-single,pins = <
+			0x150 ( PIN_INPUT | MUX_MODE0 )		/* (A17) spi0_sclk.spi0_sclk */
+			0x154 ( PIN_INPUT | MUX_MODE0 )		/* (B17) spi0_d0.spi0_d0 */
+			0x158 ( PIN_OUTPUT | MUX_MODE0 )	/* (B16) spi0_d1.spi0_d1 */
+			0x15C ( PIN_OUTPUT | MUX_MODE0 )	/* (A16) spi0_cs0.spi0_cs0 */
+		>;
+	};
+};
+
+&i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0_pins>;
+	status = "okay";
+
+	clock-frequency = <400000>;
+
+	tps: tps@2d {
+		reg = <0x2d>;
+	};
+
+	eeprom: eeprom@50 {
+		compatible = "at,24c256";
+		reg = <0x50>;
+	};
+};
+
+&cppi41dma  {
+	status = "okay";
+};
+
+&elm {
+	status = "okay";
+};
+
+&gpmc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&nandflash_pins_s0>;
+	status = "disabled";
+
+	ranges = <0 0 0x08000000 0x10000000>;	/* CS0: 16MB for NAND */
+	nand@0,0 {
+		reg = <0 0 4>; /* CS0, offset 0, IO size 4 */
+		ti,nand-ecc-opt = "ham1";
+		ti,elm-id = <&elm>;
+		nand-bus-width = <8>;
+		gpmc,device-width = <1>;
+		gpmc,sync-clk-ps = <0>;
+		gpmc,cs-on-ns = <0>;
+		gpmc,cs-rd-off-ns = <44>;
+		gpmc,cs-wr-off-ns = <44>;
+		gpmc,adv-on-ns = <6>;
+		gpmc,adv-rd-off-ns = <34>;
+		gpmc,adv-wr-off-ns = <44>;
+		gpmc,we-on-ns = <0>;
+		gpmc,we-off-ns = <40>;
+		gpmc,oe-on-ns = <0>;
+		gpmc,oe-off-ns = <54>;
+		gpmc,access-ns = <64>;
+		gpmc,rd-cycle-ns = <82>;
+		gpmc,wr-cycle-ns = <82>;
+		gpmc,wait-on-read = "true";
+		gpmc,wait-on-write = "true";
+		gpmc,bus-turnaround-ns = <0>;
+		gpmc,cycle2cycle-delay-ns = <0>;
+		gpmc,clk-activation-ns = <0>;
+		gpmc,wait-monitoring-ns = <0>;
+		gpmc,wr-access-ns = <40>;
+		gpmc,wr-data-mux-bus-ns = <0>;
+	};
+};
+
+#include "tps65910.dtsi"
+
+&tps {
+	vcc1-supply = <&vbat>;
+	vcc2-supply = <&vbat>;
+	vcc3-supply = <&vbat>;
+	vcc4-supply = <&vbat>;
+	vcc5-supply = <&vbat>;
+	vcc6-supply = <&vbat>;
+	vcc7-supply = <&vbat>;
+	vccio-supply = <&vbat>;
+
+	regulators {
+		vrtc_reg: regulator@0 {
+			regulator-always-on;
+		};
+
+		vio_reg: regulator@1 {
+			regulator-always-on;
+		};
+
+		vdd1_reg: regulator@2 {
+			/* VDD_MPU voltage limits 0.95V - 1.26V with +/-4% tolerance */
+			regulator-name = "vdd_mpu";
+			regulator-min-microvolt = <912500>;
+			regulator-max-microvolt = <1312500>;
+			regulator-boot-on;
+			regulator-always-on;
+		};
+
+		vdd2_reg: regulator@3 {
+			/* VDD_CORE voltage limits 0.95V - 1.1V with +/-4% tolerance */
+			regulator-name = "vdd_core";
+			regulator-min-microvolt = <912500>;
+			regulator-max-microvolt = <1150000>;
+			regulator-boot-on;
+			regulator-always-on;
+		};
+
+		vdd3_reg: regulator@4 {
+			regulator-always-on;
+		};
+
+		vdig1_reg: regulator@5 {
+			regulator-always-on;
+		};
+
+		vdig2_reg: regulator@6 {
+			regulator-always-on;
+		};
+
+		vpll_reg: regulator@7 {
+			regulator-always-on;
+		};
+
+		vdac_reg: regulator@8 {
+			regulator-always-on;
+		};
+
+		vaux1_reg: regulator@9 {
+			regulator-always-on;
+		};
+
+		vaux2_reg: regulator@10 {
+			regulator-always-on;
+		};
+
+		vaux33_reg: regulator@11 {
+			regulator-always-on;
+		};
+
+		vmmc_reg: regulator@12 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+		};
+	};
+};
+
+&mmc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc2_pins>;
+	status = "disabled";
+
+	vmmc-supply = <&vmmc_reg>;
+	bus-width = <8>;
+	non-removable;
+};
+
+&edma {
+	status = "okay";
+};
+
+&gpio0 {
+	u-boot,dm-spl;
+};
+
+&spi0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi0_pins>;
+	status = "disabled";
+};
diff --git a/arch/arm/mach-omap2/Kconfig b/arch/arm/mach-omap2/Kconfig
index d9bdcb355a..6e4d9fd13a 100644
--- a/arch/arm/mach-omap2/Kconfig
+++ b/arch/arm/mach-omap2/Kconfig
@@ -199,6 +199,7 @@ source "board/ti/ti814x/Kconfig"
 source "board/ti/ti816x/Kconfig"
 source "board/ti/am43xx/Kconfig"
 source "board/ti/am335x/Kconfig"
+source "board/bytesatwork/byteengine_am335x/Kconfig"
 source "board/compulab/cm_t335/Kconfig"
 source "board/compulab/cm_t43/Kconfig"
 
diff --git a/arch/arm/mach-omap2/am33xx/Kconfig b/arch/arm/mach-omap2/am33xx/Kconfig
index 2dac97a530..0a987463dc 100644
--- a/arch/arm/mach-omap2/am33xx/Kconfig
+++ b/arch/arm/mach-omap2/am33xx/Kconfig
@@ -118,6 +118,15 @@ config TARGET_BRPPT1
 	bool "Support BRPPT1"
 	select BOARD_LATE_INIT
 
+config TARGET_BYTEENGINE_AM335X
+	bool "Support byteENGINE AM335x"
+	select BOARD_LATE_INIT
+	select DM
+	select DM_SERIAL
+	select DM_GPIO
+	help
+	  Support for the bytesatwork byteENGINE AM335x
+
 config TARGET_CHILIBOARD
 	bool "Grinn chiliBoard"
 	select AM33XX_CHILISOM
diff --git a/board/bytesatwork/byteengine_am335x/Kconfig b/board/bytesatwork/byteengine_am335x/Kconfig
new file mode 100644
index 0000000000..02b90445e2
--- /dev/null
+++ b/board/bytesatwork/byteengine_am335x/Kconfig
@@ -0,0 +1,44 @@
+if TARGET_BYTEENGINE_AM335X
+
+config SYS_BOARD
+	default "byteengine_am335x"
+
+config SYS_VENDOR
+	default "bytesatwork"
+
+config SYS_SOC
+	default "am33xx"
+
+config SYS_CONFIG_NAME
+	default "byteengine_am335x"
+
+config CONS_INDEX
+	int "UART used for console"
+	range 1 6
+	default 1
+	help
+	  The AM335x SoC has a total of 6 UARTs (UART0 to UART5 as referenced
+	  in documentation, etc) available to it.  Depending on your specific
+	  board you may want something other than UART0 as for example the IDK
+	  uses UART3 so enter 4 here.
+
+config CMD_M2CONFIG
+	bool "m2config command"
+	depends on M2CONFIG_EEPROM || M2CONFIG_BUILTIN
+	default y
+	help
+	  Enable m2config command functionality.
+
+config M2CONFIG_EEPROM
+	bool "m2config eeprom support"
+	default y
+	help
+	  Enable m2config EEPROM read/write functionality.
+
+config M2CONFIG_BUILTIN
+	bool "m2config builtin support"
+	default y
+	help
+	  Enable m2config builtin configuration functionality.
+
+endif
diff --git a/board/bytesatwork/byteengine_am335x/MAINTAINERS b/board/bytesatwork/byteengine_am335x/MAINTAINERS
new file mode 100644
index 0000000000..13ba4d13f4
--- /dev/null
+++ b/board/bytesatwork/byteengine_am335x/MAINTAINERS
@@ -0,0 +1,7 @@
+BYTEENGINE_AM335X
+M:	Markus Kappeler <markus.kappeler@bytesatwork.ch>
+S:	Maintained
+F:	board/bytesatwork/byteengine_am335x/
+F:	include/configs/byteengine_am335x.h
+F:	configs/am335x_bytedevkit_emmc_defconfig
+F:	configs/am335x_bytedevkit_nand_defconfig
diff --git a/board/bytesatwork/byteengine_am335x/Makefile b/board/bytesatwork/byteengine_am335x/Makefile
new file mode 100644
index 0000000000..b925750c0a
--- /dev/null
+++ b/board/bytesatwork/byteengine_am335x/Makefile
@@ -0,0 +1,21 @@
+# SPDX-License-Identifier: GPL-2.0+
+#
+# Makefile
+#
+# Copyright (C) 2018 bytes at work AG
+#
+# Based on board/ti/am335x/Makefile
+#
+# Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+
+ifeq ($(CONFIG_SKIP_LOWLEVEL_INIT),)
+obj-y	:= mux.o
+obj-y	+= ram.o
+endif
+
+obj-y	+= board.o
+obj-y	+= m2config/m2config.o
+obj-y	+= m2config/m2config_get.o
+obj-$(CONFIG_M2CONFIG_EEPROM)	+= m2config/m2config_eeprom.o
+obj-$(CONFIG_M2CONFIG_BUILTIN)	+= m2config/m2config_builtin.o
+obj-$(CONFIG_CMD_M2CONFIG)	+= m2config/cmd_m2config.o
diff --git a/board/bytesatwork/byteengine_am335x/board.c b/board/bytesatwork/byteengine_am335x/board.c
new file mode 100644
index 0000000000..397159d32b
--- /dev/null
+++ b/board/bytesatwork/byteengine_am335x/board.c
@@ -0,0 +1,149 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 bytes at work AG
+ */
+
+#include <common.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/omap.h>
+#include <asm/arch/mem.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/mmc_host_def.h>
+#include <asm/arch/mux.h>
+#include <asm-generic/gpio.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/emif.h>
+#include <asm/io.h>
+#include <cpsw.h>
+#include <power/tps65910.h>
+#include <environment.h>
+#include <errno.h>
+#include <miiphy.h>
+#include <spl.h>
+#include <watchdog.h>
+#include "board.h"
+#include "m2config/m2config_eeprom.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static __maybe_unused struct ctrl_dev *cdev =
+	(struct ctrl_dev *)CTRL_DEVICE_BASE;
+
+void set_uart_mux_conf(void)
+{
+	enable_uart0_pin_mux();
+}
+
+void set_mux_conf_regs(void)
+{
+	enable_board_pin_mux();
+}
+
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+void am33xx_spl_board_init(void)
+{
+	int mpu_vdd;
+	int sil_rev;
+
+	/* Get the frequency */
+	dpll_mpu_opp100.m = am335x_get_efuse_mpu_max_freq(cdev);
+
+	/*
+	 * Depending on MPU clock and PG we will need a different
+	 * VDD to drive at that speed.
+	 */
+	sil_rev = readl(&cdev->deviceid) >> 28;
+	mpu_vdd = am335x_get_tps65910_mpu_vdd(sil_rev,
+					      dpll_mpu_opp100.m);
+
+	/* Tell the TPS65910 to use i2c */
+	tps65910_set_i2c_control();
+
+	/* First update MPU voltage. */
+	if (tps65910_voltage_update(MPU, mpu_vdd))
+		return;
+
+	/* Second, update the CORE voltage. */
+	if (tps65910_voltage_update(CORE, TPS65910_OP_REG_SEL_1_1_3))
+		return;
+
+	/* Set CORE Frequencies to OPP100 */
+	do_setup_dpll(&dpll_core_regs, &dpll_core_opp100);
+
+	/* Set MPU Frequency to what we detected now that voltages are set */
+	do_setup_dpll(&dpll_mpu_regs, &dpll_mpu_opp100);
+}
+#endif
+
+/*
+ * Basic board specific setup.  Pinmux has been handled already.
+ */
+int board_init(void)
+{
+	m2config_eeprom_init();
+#ifdef CONFIG_HW_WATCHDOG
+	hw_watchdog_init();
+#endif
+
+	gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
+#ifdef CONFIG_NAND
+	gpmc_init();
+#endif
+
+	return 0;
+}
+
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	return 0;
+}
+
+#ifdef CONFIG_BOARD_LATE_INIT
+int board_late_init(void)
+{
+#ifndef CONFIG_SPL_BUILD
+	u8 mac_addr[6];
+	u32 mac_hi, mac_lo;
+
+	/* Reset PHY */
+	gpio_request(13, "PHY_RESET");
+	gpio_direction_output(13, 0);
+	udelay(100 * 1000);
+	gpio_set_value(13, 1);
+
+	/* try reading mac address from efuse */
+	mac_lo = readl(&cdev->macid0l);
+	mac_hi = readl(&cdev->macid0h);
+	mac_addr[0] = mac_hi & 0xFF;
+	mac_addr[1] = (mac_hi & 0xFF00) >> 8;
+	mac_addr[2] = (mac_hi & 0xFF0000) >> 16;
+	mac_addr[3] = (mac_hi & 0xFF000000) >> 24;
+	mac_addr[4] = mac_lo & 0xFF;
+	mac_addr[5] = (mac_lo & 0xFF00) >> 8;
+
+	if (!env_get("ethaddr")) {
+		printf("<ethaddr> not set. Validating first E-fuse MAC\n");
+
+		if (is_valid_ethaddr(mac_addr))
+			eth_env_set_enetaddr("ethaddr", mac_addr);
+	}
+
+	mac_lo = readl(&cdev->macid1l);
+	mac_hi = readl(&cdev->macid1h);
+	mac_addr[0] = mac_hi & 0xFF;
+	mac_addr[1] = (mac_hi & 0xFF00) >> 8;
+	mac_addr[2] = (mac_hi & 0xFF0000) >> 16;
+	mac_addr[3] = (mac_hi & 0xFF000000) >> 24;
+	mac_addr[4] = mac_lo & 0xFF;
+	mac_addr[5] = (mac_lo & 0xFF00) >> 8;
+
+	if (!env_get("eth1addr")) {
+		if (is_valid_ethaddr(mac_addr))
+			eth_env_set_enetaddr("eth1addr", mac_addr);
+	}
+#endif
+
+	return 0;
+}
+#endif
diff --git a/board/bytesatwork/byteengine_am335x/board.h b/board/bytesatwork/byteengine_am335x/board.h
new file mode 100644
index 0000000000..2fe6169886
--- /dev/null
+++ b/board/bytesatwork/byteengine_am335x/board.h
@@ -0,0 +1,37 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 bytes at work AG
+ *
+ * Based on board/ti/am335x/board.h
+ *
+ * TI AM335x boards information header
+ *
+ * Copyright (C) 2011, Texas Instruments, Incorporated - http://www.ti.com/
+ */
+
+#ifndef BOARD_H
+#define BOARD_H
+
+/**
+ * AM335X (EMIF_4D) EMIF REG_COS_COUNT_1, REG_COS_COUNT_2, and
+ * REG_PR_OLD_COUNT values to avoid LCDC DMA FIFO underflows and Frame
+ * Synchronization Lost errors. The values are the biggest that work
+ * reliably with offered video modes and the memory subsystem on the
+ * boards. These register have are briefly documented in "7.3.3.5.2
+ * Command Starvation" section of AM335x TRM. The REG_COS_COUNT_1 and
+ * REG_COS_COUNT_2 do not have any effect on current versions of
+ * AM335x.
+ */
+#define EMIF_OCP_CONFIG				EMIF1_BASE + 0x54
+#define EMIF_OCP_CONFIG_BYTEENGINE_AM335X	0x00383838
+
+/*
+ * We have three pin mux functions that must exist.  We must be able to enable
+ * uart0, for initial output and i2c0 to read the main EEPROM.  We then have a
+ * main pinmux function that can be overridden to enable all other pinmux that
+ * is required on the board.
+ */
+void enable_uart0_pin_mux(void);
+void enable_i2c0_pin_mux(void);
+void enable_board_pin_mux(void);
+#endif
diff --git a/board/bytesatwork/byteengine_am335x/ddr_defs_baw.h b/board/bytesatwork/byteengine_am335x/ddr_defs_baw.h
new file mode 100644
index 0000000000..817bafad5b
--- /dev/null
+++ b/board/bytesatwork/byteengine_am335x/ddr_defs_baw.h
@@ -0,0 +1,59 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * ddr definitions for chips used by bytes at work
+ *
+ * Copyright (C) 2018 bytes at work AG
+ */
+
+#ifndef DDR_DEFS_BAW_H
+#define DDR_DEFS_BAW_H
+
+/* Samsung K4B2G1646Q-BCK0 (256MB DDR3) */
+#define K4B2G1646QBCK0_EMIF_READ_LATENCY	0x100007
+#define K4B2G1646QBCK0_EMIF_TIM1		0x0AAAE51B
+#define K4B2G1646QBCK0_EMIF_TIM2		0x2A437FDA
+#define K4B2G1646QBCK0_EMIF_TIM3		0x501F83FF
+#define K4B2G1646QBCK0_EMIF_SDCFG		0x61C052B2
+#define K4B2G1646QBCK0_EMIF_SDREF		0x00000C30
+#define K4B2G1646QBCK0_ZQ_CFG			0x50074BE4
+#define K4B2G1646QBCK0_RATIO			0x80
+#define K4B2G1646QBCK0_INVERT_CLKOUT		0x0
+#define K4B2G1646QBCK0_RD_DQS			0x35
+#define K4B2G1646QBCK0_WR_DQS			0x3A
+#define K4B2G1646QBCK0_PHY_FIFO_WE		0x97
+#define K4B2G1646QBCK0_PHY_WR_DATA		0x76
+#define K4B2G1646QBCK0_IOCTRL_VALUE		0x18B
+
+/* Samsung K4B4G1646D-BIK0 (512MB DDR3) */
+#define K4B4G1646DBIK0_EMIF_READ_LATENCY	0x100007
+#define K4B4G1646DBIK0_EMIF_TIM1		0x0AAAE51B
+#define K4B4G1646DBIK0_EMIF_TIM2		0x2A6B7FDA
+#define K4B4G1646DBIK0_EMIF_TIM3		0x501F867F
+#define K4B4G1646DBIK0_EMIF_SDCFG		0x61C052B2
+#define K4B4G1646DBIK0_EMIF_SDREF		0x00000C30
+#define K4B4G1646DBIK0_ZQ_CFG			0x50074BE4
+#define K4B4G1646DBIK0_RATIO			0x80
+#define K4B4G1646DBIK0_INVERT_CLKOUT		0x0
+#define K4B4G1646DBIK0_RD_DQS			0x35
+#define K4B4G1646DBIK0_WR_DQS			0x3A
+#define K4B4G1646DBIK0_PHY_FIFO_WE		0x97
+#define K4B4G1646DBIK0_PHY_WR_DATA		0x76
+#define K4B4G1646DBIK0_IOCTRL_VALUE		0x18B
+
+/* Micron MT41K512M16HA-107 IT:A D9SGD (1024MB DDR3) */
+#define MT41K512M16HA107_EMIF_READ_LATENCY	0x100007
+#define MT41K512M16HA107_EMIF_TIM1		0x0AA15CA3
+#define MT41K512M16HA107_EMIF_TIM2		0x2A8F7FDA
+#define MT41K512M16HA107_EMIF_TIM3		0x501F88BF
+#define MT41K512M16HA107_EMIF_SDCFG		0x61C04BB2
+#define MT41K512M16HA107_EMIF_SDREF		0x0000093B
+#define MT41K512M16HA107_ZQ_CFG			0x50074BE4
+#define MT41K512M16HA107_RATIO			0x80
+#define MT41K512M16HA107_INVERT_CLKOUT		0x0
+#define MT41K512M16HA107_RD_DQS			0x35
+#define MT41K512M16HA107_WR_DQS			0x3A
+#define MT41K512M16HA107_PHY_FIFO_WE		0x79
+#define MT41K512M16HA107_PHY_WR_DATA		0x76
+#define MT41K512M16HA107_IOCTRL_VALUE		0x18B
+
+#endif
diff --git a/board/bytesatwork/byteengine_am335x/m2config/README b/board/bytesatwork/byteengine_am335x/m2config/README
new file mode 100644
index 0000000000..f82ef75ac3
--- /dev/null
+++ b/board/bytesatwork/byteengine_am335x/m2config/README
@@ -0,0 +1,68 @@
+
+Configuration options:
+
+CONFIG_CMD_M2CONFIG
+If defined, add the u-boot command m2config to read and write the configuration.
+
+CONFIG_M2CONFIG_EEPROM
+If defined, add method to read (SPL) and write (SPL and u-boot) the
+configuration from the eeprom.
+
+CONFIG_M2CONFIG_BUILTIN
+If defined, add built-in configuration values. Define the following names:
+  M2CONFIG_BUILTIN_PCB
+  M2CONFIG_BUILTIN_RAM
+  M2CONFIG_BUILTIN_FLASH
+
+If both CONFIG_M2CONFIG_EEPROM and CONFIG_M2CONFIG_BUILTIN are defined, the
+order is defined in m2config_get.
+
+At least one of CONFIG_M2CONFIG_EEPROM or CONFIG_M2CONFIG_BUILTIN has to be
+defined.
+
+
+EEPROM format
+
+Byte order is the native byte order of the CPU. The format is:
+
+Bytes  Usage
+  2    Magic
+  2    length
+  4    PCB
+  4    RAM
+  4    Flash
+  4    CRC
+
+Magic is 0x6268. CRC is the native u-boot crc32.
+
+
+Extended data EEPROM format
+
+Byte order is the native byte order of the CPU. The format is:
+
+Bytes  Usage
+  2    Magic ext.
+  2    length
+  4    CRC
+  4    Article number
+  4    Lot
+  1    Lot sequence number
+ 12    Production date
+  6    Flash date
+  6    Flash user
+
+Magic is 0x6235. CRC is the native u-boot crc32.
+
+
+Tracking data EEPROM format
+
+Byte order is the native byte order of the CPU. The format is:
+
+Bytes  Usage
+  2    Magic (tracking data)
+  2    length
+  4    CRC
+ 18    MAC address
+ 16    UID
+
+Magic is 0x6e4a. CRC is the native u-boot crc32.
diff --git a/board/bytesatwork/byteengine_am335x/m2config/cmd_m2config.c b/board/bytesatwork/byteengine_am335x/m2config/cmd_m2config.c
new file mode 100644
index 0000000000..e1bfdedc31
--- /dev/null
+++ b/board/bytesatwork/byteengine_am335x/m2config/cmd_m2config.c
@@ -0,0 +1,223 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2015 bytes at work AG
+ */
+
+#include <common.h>
+#include <command.h>
+#include <post.h>
+#include "m2config_builtin.h"
+#include "m2config_eeprom.h"
+
+static void print_config(const struct m2config *config)
+{
+	printf("PCB:   %u (%s)\n", config->pcb,
+	       m2config_get_pcb_name(config->pcb));
+	printf("RAM:   %u (%s)\n", config->ram,
+	       m2config_get_ram_name(config->ram));
+	printf("Flash: %u (%s)\n", config->flash,
+	       m2config_get_flash_name(config->flash));
+
+	if (config->ext_avail == 1) {
+		printf("\n");
+		printf("Article number:  %u\n", config->artno);
+		printf("Lot:             %u.%u\n", config->lot, config->lotseq);
+		printf("Production date: %s\n", config->proddate);
+		printf("Flash date:      %s\n", config->flashdate);
+		printf("Flash user:      %s\n", config->flashuser);
+	}
+
+	if (config->track_avail == 1) {
+		printf("\n");
+		printf("MAC address:     %s\n", config->macaddr);
+		printf("UID:             %s\n", config->uid);
+	}
+}
+
+#if defined(CONFIG_M2CONFIG_BUILTIN)
+static enum command_ret_t cmd_builtin(int argc, char * const argv[])
+{
+	struct m2config config;
+
+	if (argc != 0)
+		return CMD_RET_USAGE;
+
+	if (m2config_builtin(&config) != 0) {
+		printf("could not get built-in configuration\n");
+		return CMD_RET_FAILURE;
+	}
+
+	print_config(&config);
+
+	return CMD_RET_SUCCESS;
+}
+#endif
+
+#if defined(CONFIG_M2CONFIG_EEPROM)
+static enum command_ret_t cmd_read(int argc, char * const argv[])
+{
+	struct m2config config;
+	int ret;
+
+	if (argc != 0)
+		return CMD_RET_USAGE;
+
+	ret = m2config_eeprom_read(&config);
+	if (ret != 0)
+		printf("no configuration in eeprom: %i\n", ret);
+	else
+		print_config(&config);
+
+	return CMD_RET_SUCCESS;
+}
+
+static enum command_ret_t cmd_write(int argc, char * const argv[])
+{
+	struct m2config config;
+
+	if (argc != 11)
+		return CMD_RET_USAGE;
+
+	config.pcb = simple_strtoul(argv[0], NULL, 10);
+	config.ram = simple_strtoul(argv[1], NULL, 10);
+	config.flash = simple_strtoul(argv[2], NULL, 10);
+
+	config.artno = simple_strtoul(argv[3], NULL, 10);
+	config.lot = simple_strtoul(argv[4], NULL, 10);
+	config.lotseq = simple_strtoul(argv[5], NULL, 10);
+	strlcpy(config.proddate, argv[6], sizeof(config.proddate));
+	strlcpy(config.flashdate, argv[7], sizeof(config.flashdate));
+	strlcpy(config.flashuser, argv[8], sizeof(config.flashuser));
+
+	strlcpy(config.macaddr, argv[9], sizeof(config.macaddr));
+	strlcpy(config.uid, argv[10], sizeof(config.uid));
+
+	if (m2config_eeprom_write(&config) != 0) {
+		printf("could not write to EEPROM\n");
+		return CMD_RET_FAILURE;
+	}
+
+	return CMD_RET_SUCCESS;
+}
+
+static enum command_ret_t cmd_erase(int argc, char * const argv[])
+{
+	if (argc != 0)
+		return CMD_RET_USAGE;
+
+	if (m2config_eeprom_erase() != 0) {
+		printf("could not erase configuration\n");
+		return CMD_RET_FAILURE;
+	}
+
+	return CMD_RET_SUCCESS;
+}
+
+#if defined(CONFIG_M2CONFIG_BUILTIN)
+static enum command_ret_t cmd_builtin2eeprom(int argc, char * const argv[])
+{
+	struct m2config config;
+
+	if (argc != 0)
+		return CMD_RET_USAGE;
+
+	if (m2config_builtin(&config) != 0) {
+		printf("could not get built-in configuration\n");
+		return CMD_RET_FAILURE;
+	}
+
+	if (m2config_eeprom_write(&config) != 0) {
+		printf("could not write to EEPROM\n");
+		return CMD_RET_FAILURE;
+	}
+
+	return CMD_RET_SUCCESS;
+}
+#endif
+#endif
+
+struct m2config_cmd_struct {
+		char  *name;
+		enum command_ret_t (*func)(int argc, char * const argv[]);
+};
+
+static const struct m2config_cmd_struct m2config_cmd[] = {
+#if defined(CONFIG_M2CONFIG_BUILTIN)
+	{ "builtin", cmd_builtin },
+#endif
+#if defined(CONFIG_M2CONFIG_EEPROM)
+	{ "read", cmd_read },
+	{ "erase", cmd_erase },
+	{ "write", cmd_write },
+#if defined(CONFIG_M2CONFIG_BUILTIN)
+	{ "builtin2eeprom", cmd_builtin2eeprom },
+#endif
+#endif
+	{ NULL, NULL }
+};
+
+static const struct m2config_cmd_struct *get_cmd(const char *name)
+{
+	const struct m2config_cmd_struct *cmd;
+
+	for (cmd = m2config_cmd; cmd->name; cmd++)
+		if (strcmp(name, cmd->name) == 0)
+			return cmd;
+
+	return NULL;
+}
+
+static void print_config_names(const struct m2config_name_pair *map)
+{
+	const struct m2config_name_pair *itr;
+
+	for (itr = map; itr->name; itr++)
+		printf("  %u (%s)\n", itr->config, itr->name);
+}
+
+static enum command_ret_t print_configurations(void)
+{
+	printf("PCB:\n");
+	print_config_names(m2config_pcb_name);
+	printf("RAM:\n");
+	print_config_names(m2config_ram_name);
+	printf("Flash:\n");
+	print_config_names(m2config_flash_name);
+
+	return CMD_RET_SUCCESS;
+}
+
+enum command_ret_t do_m2config(cmd_tbl_t *cmdtp, int flag, int argc,
+			       char * const argv[])
+{
+	if (argc >= 2) {
+		const struct m2config_cmd_struct *cmd = get_cmd(argv[1]);
+
+		if (cmd)
+			return cmd->func(argc - 2, &argv[2]);
+		else
+			return CMD_RET_USAGE;
+	}
+
+	return print_configurations();
+}
+
+U_BOOT_CMD(
+	m2config, 13, 0, do_m2config,
+	"perform m2 configuration",
+	"- list known configuration values\n"
+#if defined(CONFIG_M2CONFIG_BUILTIN)
+	"builtin  - print built-in configuration from u-boot\n"
+#endif
+#if defined(CONFIG_M2CONFIG_EEPROM)
+	"read     - read configuration from EEPROM\n"
+	"erase    - erase configuration from EEPROM\n"
+	"write <PCB> <RAM> <Flash> <Article number> <Lot> <Lot sequence number>\n"
+	"      <Production date> <Flash date> <Flash user> <MAC address> <UID>\n"
+	"         - write configuration to EEPROM\n"
+#if defined(CONFIG_M2CONFIG_BUILTIN)
+	"builtin2eeprom\n"
+	"         - write built-in configuration to EEPROM\n"
+#endif
+#endif
+);
diff --git a/board/bytesatwork/byteengine_am335x/m2config/m2config.c b/board/bytesatwork/byteengine_am335x/m2config/m2config.c
new file mode 100644
index 0000000000..202e888382
--- /dev/null
+++ b/board/bytesatwork/byteengine_am335x/m2config/m2config.c
@@ -0,0 +1,45 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2015 bytes at work AG
+ */
+
+#include "m2config.h"
+
+const struct m2config_name_pair m2config_pcb_name[] = {
+	{ M2_PCB_REV_00, "Rev.00" },
+	{ M2_PCB_REV_01, "Rev.01" },
+	{ M2_PCB_REV_02, "Rev.02" },
+	{ M2_PCB_REV_03, "Rev.03" },
+	{ M2_PCB_REV_04, "Rev.04" },
+	{ -1, NULL },
+};
+
+const struct m2config_name_pair m2config_ram_name[] = {
+	{ M2_RAM_MT47H128M16RT25E, "MT47H128M16RT25E 256 MB DDR2 @ 266MHz" },
+	{ M2_RAM_K4B2G1646EBIH9,   "K4B2G1646EBIH9 legacy DDR3 @ 303MHz" },
+	{ M2_RAM_K4B2G1646QBCK0,   "K4B2G1646QBCK0 256 MB DDR3 @ 400Mhz" },
+	{ M2_RAM_K4B4G1646DBIK0,   "K4B4G1646DBIK0 512 MB DDR3 @ 400MHz" },
+	{ M2_RAM_MT41K512M16HA107, "MT41K512M16HA107 1024MB DDR3 @ 303MHz" },
+	{ -1, NULL },
+};
+
+const struct m2config_name_pair m2config_flash_name[] = {
+	{ M2_NAND_2GBIT, "Nand 2 GBit" },
+	{ M2_NAND_4GBIT, "Nand 4 GBit" },
+	{ M2_EMMC_4GB, "EMMC 4 GB" },
+	{ M2_EMMC_8GB, "EMMC 8 GB" },
+	{ M2_EMMC_16GB, "EMMC 16 GB" },
+	{ M2_EMMC_32GB, "EMMC 32 GB" },
+	{ -1, NULL },
+};
+
+const char *m2config_get_name(u32 config, const struct m2config_name_pair *map)
+{
+	const struct m2config_name_pair *itr;
+
+	for (itr = map; itr->name; itr++)
+		if (itr->config == config)
+			return itr->name;
+
+	return "unknown";
+}
diff --git a/board/bytesatwork/byteengine_am335x/m2config/m2config.h b/board/bytesatwork/byteengine_am335x/m2config/m2config.h
new file mode 100644
index 0000000000..4ef104b379
--- /dev/null
+++ b/board/bytesatwork/byteengine_am335x/m2config/m2config.h
@@ -0,0 +1,79 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2015 bytes at work AG
+ */
+
+#ifndef M2CONFIG_H
+#define M2CONFIG_H
+
+#include <config.h>
+#include <linux/types.h>
+
+typedef enum {
+	M2_PCB_REV_00 = 0,
+	M2_PCB_REV_01 = 1,
+	M2_PCB_REV_02 = 2,
+	M2_PCB_REV_03 = 3,
+	M2_PCB_REV_04 = 4,
+} m2config_pcb_t;
+
+typedef enum {
+	M2_RAM_MT47H128M16RT25E = 1,
+	M2_RAM_K4B2G1646EBIH9   = 2,
+	M2_RAM_K4B2G1646QBCK0   = 3,
+	M2_RAM_K4B4G1646DBIK0   = 4,
+	M2_RAM_MT41K512M16HA107 = 5,
+} m2config_ram_t;
+
+typedef enum {
+	M2_NAND_2GBIT  = 0,
+	M2_NAND_4GBIT  = 1,
+	M2_EMMC_4GB  = 2,
+	M2_EMMC_8GB  = 3,
+	M2_EMMC_16GB = 4,
+	M2_EMMC_32GB = 5,
+} m2config_flash_t;
+
+struct m2config {
+	m2config_pcb_t		pcb;
+	m2config_ram_t		ram;
+	m2config_flash_t	flash;
+	bool			ext_avail;
+	u32		artno;
+	u32		lot;
+	u8			lotseq;
+	char			proddate[12];
+	char			flashdate[6];
+	char			flashuser[6];
+	bool			track_avail;
+	char			macaddr[18];
+	char			uid[16];
+};
+
+struct m2config_name_pair {
+	u32	config;
+	const char	*name;
+};
+
+extern const struct m2config_name_pair m2config_pcb_name[];
+extern const struct m2config_name_pair m2config_ram_name[];
+extern const struct m2config_name_pair m2config_flash_name[];
+
+const char *m2config_get_name(u32 config, const struct m2config_name_pair *map);
+
+static inline const char *m2config_get_pcb_name(m2config_pcb_t config)
+{
+	return m2config_get_name(config, m2config_pcb_name);
+}
+
+static inline const char *m2config_get_ram_name(m2config_ram_t config)
+{
+	return m2config_get_name(config, m2config_ram_name);
+}
+
+static inline const char *m2config_get_flash_name(m2config_flash_t config)
+{
+	return m2config_get_name(config, m2config_flash_name);
+}
+
+#endif
diff --git a/board/bytesatwork/byteengine_am335x/m2config/m2config_builtin.c b/board/bytesatwork/byteengine_am335x/m2config/m2config_builtin.c
new file mode 100644
index 0000000000..ccce010797
--- /dev/null
+++ b/board/bytesatwork/byteengine_am335x/m2config/m2config_builtin.c
@@ -0,0 +1,15 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2015 bytes at work AG
+ */
+
+#include "m2config.h"
+#include <config.h>
+
+int m2config_builtin(struct m2config *config)
+{
+	config->pcb    = M2CONFIG_BUILTIN_PCB;
+	config->ram    = M2CONFIG_BUILTIN_RAM;
+	config->flash  = M2CONFIG_BUILTIN_FLASH;
+	return 0;
+}
diff --git a/board/bytesatwork/byteengine_am335x/m2config/m2config_builtin.h b/board/bytesatwork/byteengine_am335x/m2config/m2config_builtin.h
new file mode 100644
index 0000000000..09b59265f4
--- /dev/null
+++ b/board/bytesatwork/byteengine_am335x/m2config/m2config_builtin.h
@@ -0,0 +1,21 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2015 bytes at work AG
+ */
+
+#ifndef M2CONFIG_BUILTIN_H
+#define M2CONFIG_BUILTIN_H
+
+#include "m2config.h"
+#include <config.h>
+
+#if defined(CONFIG_M2CONFIG_BUILTIN)
+int m2config_builtin(struct m2config *config);
+#else
+static inline int m2config_builtin(struct m2config *config)
+{
+	return -1;
+}
+#endif
+
+#endif
diff --git a/board/bytesatwork/byteengine_am335x/m2config/m2config_eeprom.c b/board/bytesatwork/byteengine_am335x/m2config/m2config_eeprom.c
new file mode 100644
index 0000000000..4aebac3c5a
--- /dev/null
+++ b/board/bytesatwork/byteengine_am335x/m2config/m2config_eeprom.c
@@ -0,0 +1,301 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2015 bytes at work AG
+ */
+
+#include "m2config_eeprom.h"
+
+#include "m2config.h"
+
+#include <common.h>
+#include <dm/uclass.h>
+#include <i2c.h>
+#include <hexdump.h>
+
+#define EEPROM_ADDRESS		0x50
+#define EEPROM_MAXWRITE		64	/* max. page size for writes */
+#define MAGIC			0x6268
+#define EEPROM_EXT_OFFSET	0x14
+#define MAGIC_EXT		0x6235
+#define EEPROM_TRACK_OFFSET	0x3d
+#define MAGIC_TRACK		0x6e4a
+
+struct udevice *m2config_dev, *busp;
+
+struct eeprom_header {
+	u16 magic;
+	u16 length;
+} __packed;
+
+struct eeprom_content {
+	u32	pcb;
+	u32	ram;
+	u32	flash;
+} __packed;
+
+struct eeprom_content_ext {
+	u32	artno;
+	u32	lot;
+	u8		lotseq;
+	char		proddate[12];
+	char		flashdate[6];
+	char		flashuser[6];
+} __packed;
+
+struct eeprom_content_track {
+	char		macaddr[18];
+	char		uid[16];	/* enable use of characters */
+} __packed;
+
+struct eeprom_data {
+	struct eeprom_header	header;
+	struct eeprom_content	content;
+	u32			crc;
+} __packed;
+
+struct eeprom_data_ext {
+	struct eeprom_header		header;
+	u32				crc;
+	struct eeprom_content_ext	content;
+} __packed;
+
+struct eeprom_data_track {
+	struct eeprom_header		header;
+	u32				crc;
+	struct eeprom_content_track	content;
+} __packed;
+
+struct eeprom_write_frame {
+	struct eeprom_data		content;
+	struct eeprom_data_ext		content_ext;
+	struct eeprom_data_track	content_track;
+} __packed;
+
+struct eeprom_read_frame {
+	struct eeprom_data		content;
+	struct eeprom_data_ext		content_ext;
+	struct eeprom_data_track	content_track;
+} __packed;
+
+int m2config_eeprom_init(void)
+{
+#ifdef CONFIG_DM_I2C
+	int ret;
+
+	ret = uclass_get_device_by_seq(UCLASS_I2C, 0, &busp);
+	if (ret)
+		return ret;
+
+	ret = dm_i2c_probe(busp, EEPROM_ADDRESS, 0, &m2config_dev);
+	if (ret)
+		return ret;
+
+	ret = i2c_set_chip_offset_len(m2config_dev, 2);
+	if (ret)
+		return ret;
+
+#endif
+	return 0;
+}
+
+static int i2c_write_rdy(void)
+{
+	/*
+	 * Check if device is ready for write to eeprom. Write can last up to
+	 * 5 ms. Poll with empty write.
+	 */
+	int i, ret = -5;
+	u8 dummy = 0xff; /* i2c_write doesn't like to write NULL pointers */
+
+	for (i = 0; ret < 0 && i < 10; ++i) {
+#ifndef CONFIG_DM_I2C
+		ret = i2c_write(EEPROM_ADDRESS, 0, 2, &dummy, 0);
+#else
+		ret = dm_i2c_write(m2config_dev, 0, &dummy, 0);
+#endif
+		if (ret != 0)
+			udelay(500);
+	}
+
+	if (ret != 0)
+		printf("Error: eeprom busy, giving up.\n");
+
+	return ret;
+}
+
+int i2c_long_write(struct eeprom_write_frame frame, int len)
+{
+	int wlen, ret, off = 0;
+
+	while (len > 0) {
+		if (len >= EEPROM_MAXWRITE)
+			wlen = EEPROM_MAXWRITE;
+		else
+			wlen = len;
+
+		if (i2c_write_rdy() != 0) {
+			ret = -EIO;
+			break;
+		}
+#ifndef CONFIG_DM_I2C
+		ret = i2c_write(EEPROM_ADDRESS, off, 2, (u8 *)(&frame) + off,
+				wlen);
+#else
+		ret = dm_i2c_write(m2config_dev, off, (u8 *)(&frame) + off,
+				   wlen);
+#endif
+
+		if (ret != 0) {
+			ret = -EIO;
+			break;
+		}
+
+		len -= wlen;
+		off += wlen;
+	}
+
+	return ret;
+}
+
+int m2config_eeprom_read(struct m2config *config)
+{
+	struct eeprom_read_frame frame;
+
+#ifndef CONFIG_DM_I2C
+	if (i2c_read(EEPROM_ADDRESS, 0, 2, (u8 *)&frame, sizeof(frame)) != 0)
+		return -3;
+#else
+	if (dm_i2c_read(m2config_dev, 0, (u8 *)&frame, sizeof(frame)))
+		return -12;
+#endif
+
+	if (frame.content.header.magic != MAGIC)
+		return -4;
+
+	if (frame.content.header.length != sizeof(frame.content.content))
+		return -5;
+
+	/* Cast crc32 value to u8 because of legacy code */
+	if (frame.content.crc != (u8)crc32(0, (u8 *)&frame.content.content,
+			sizeof(frame.content.content)))
+		return -6;
+
+	config->pcb    = frame.content.content.pcb;
+	config->ram    = frame.content.content.ram;
+	config->flash  = frame.content.content.flash;
+
+	config->ext_avail = 0;
+	if (frame.content_ext.header.magic != MAGIC_EXT) {
+		printf("ext magic wrong\n");
+		return 0;
+	}
+
+	if (frame.content_ext.header.length != sizeof(frame.content_ext.content)) {
+		printf("ext len wrong\n");
+		return 0;
+	}
+
+	if (frame.content_ext.crc != crc32(0, (u8 *)&frame.content_ext.content,
+			sizeof(frame.content_ext.content))) {
+		printf("ext crc wrong\n");
+		return 0;
+	}
+
+	config->artno = frame.content_ext.content.artno;
+	config->lot = frame.content_ext.content.lot;
+	config->lotseq = frame.content_ext.content.lotseq;
+
+	strlcpy(config->proddate, frame.content_ext.content.proddate,
+		sizeof(config->proddate));
+	strlcpy(config->flashdate, frame.content_ext.content.flashdate,
+		sizeof(config->flashdate));
+	strlcpy(config->flashuser, frame.content_ext.content.flashuser,
+		sizeof(config->flashuser));
+
+	config->ext_avail = 1;
+
+	config->track_avail = 0;
+	if (frame.content_track.header.magic != MAGIC_TRACK) {
+		printf("track magic wrong\n");
+		return 0;
+	}
+
+	if (frame.content_track.header.length !=
+			sizeof(frame.content_track.content)) {
+		printf("track len wrong\n");
+		return 0;
+	}
+
+	if (frame.content_track.crc != crc32(0, (u8 *)&frame.content_track.content,
+			sizeof(frame.content_track.content))) {
+		printf("track crc wrong\n");
+		return 0;
+	}
+
+	strlcpy(config->macaddr, frame.content_track.content.macaddr,
+		sizeof(config->macaddr));
+	strlcpy(config->uid, frame.content_track.content.uid,
+		sizeof(config->uid));
+
+	config->track_avail = 1;
+
+	return 0;
+}
+
+#if defined(CONFIG_SKIP_LOWLEVEL_INIT)
+
+int m2config_eeprom_write(struct m2config *config)
+{
+	struct eeprom_write_frame   frame;
+
+	frame.content.header.magic = MAGIC;
+	frame.content.header.length = sizeof(frame.content.content);
+	frame.content.content.pcb = config->pcb;
+	frame.content.content.ram = config->ram;
+	frame.content.content.flash = config->flash;
+	/* Cast crc32 value to u8 because of legacy code */
+	frame.content.crc = (u8)crc32(0, (const u8 *)&frame.content.content,
+			sizeof(frame.content.content));
+
+	frame.content_ext.header.magic = MAGIC_EXT;
+	frame.content_ext.header.length = sizeof(frame.content_ext.content);
+	frame.content_ext.content.artno = config->artno;
+	frame.content_ext.content.lot = config->lot;
+	frame.content_ext.content.lotseq = config->lotseq;
+	strlcpy(frame.content_ext.content.proddate, config->proddate,
+		sizeof(frame.content_ext.content.proddate));
+	strlcpy(frame.content_ext.content.flashdate, config->flashdate,
+		sizeof(frame.content_ext.content.flashdate));
+	strlcpy(frame.content_ext.content.flashuser, config->flashuser,
+		sizeof(frame.content_ext.content.flashuser));
+	frame.content_ext.crc = crc32(0, (u8 *)&frame.content_ext.content,
+		sizeof(frame.content_ext.content));
+
+	frame.content_track.header.magic = MAGIC_TRACK;
+	frame.content_track.header.length = sizeof(frame.content_track.content);
+	strlcpy(frame.content_track.content.macaddr, config->macaddr,
+		sizeof(frame.content_track.content.macaddr));
+	strlcpy(frame.content_track.content.uid, config->uid,
+		sizeof(frame.content_track.content.uid));
+	frame.content_track.crc = crc32(0, (u8 *)&frame.content_track.content,
+		sizeof(frame.content_track.content));
+
+	if (i2c_long_write(frame, sizeof(frame)) != 0)
+		return -7;
+
+	return 0;
+}
+
+int m2config_eeprom_erase(void)
+{
+	struct eeprom_write_frame   frame;
+
+	memset(&frame, 0xff, sizeof(frame));
+
+	if (i2c_long_write(frame, sizeof(frame)) != 0)
+		return -8;
+
+	return 0;
+}
+
+#endif
diff --git a/board/bytesatwork/byteengine_am335x/m2config/m2config_eeprom.h b/board/bytesatwork/byteengine_am335x/m2config/m2config_eeprom.h
new file mode 100644
index 0000000000..8d9e832be2
--- /dev/null
+++ b/board/bytesatwork/byteengine_am335x/m2config/m2config_eeprom.h
@@ -0,0 +1,37 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2015 bytes at work AG
+ */
+
+#ifndef M2CONFIG_EEPROM_H
+#define M2CONFIG_EEPROM_H
+
+#include "m2config.h"
+#include <config.h>
+
+#if defined(CONFIG_M2CONFIG_EEPROM)
+int m2config_eeprom_read(struct m2config *config);
+int m2config_eeprom_init(void);
+#else
+static inline int m2config_eeprom_read(struct m2config *config)
+{
+	return -1;
+}
+#endif
+
+#if defined(CONFIG_M2CONFIG_EEPROM) && defined(CONFIG_SKIP_LOWLEVEL_INIT)
+int m2config_eeprom_write(struct m2config *config);
+int m2config_eeprom_erase(void);
+#else
+static inline int m2config_eeprom_write(struct m2config *config)
+{
+	return -1;
+}
+
+static inline int m2config_eeprom_erase(void)
+{
+	return -1;
+}
+#endif
+
+#endif
diff --git a/board/bytesatwork/byteengine_am335x/m2config/m2config_get.c b/board/bytesatwork/byteengine_am335x/m2config/m2config_get.c
new file mode 100644
index 0000000000..60386ecb89
--- /dev/null
+++ b/board/bytesatwork/byteengine_am335x/m2config/m2config_get.c
@@ -0,0 +1,45 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2015 bytes at work AG
+ */
+
+#include <asm/arch/ddr_defs.h>
+#include <i2c.h>
+#include "m2config_get.h"
+
+#include "m2config_builtin.h"
+#include "m2config_eeprom.h"
+
+#define PMIC_ADDRESS 0x2D
+
+void m2config_get(struct m2config *config)
+{
+	u8 __attribute__((unused)) reg = 0;
+
+	if (m2config_eeprom_read(config) == 0)
+		return;
+
+#ifdef CONFIG_SPL_BUILD
+	if (i2c_read(PMIC_ADDRESS, 0x20, 1, &reg, 1) != 0) {
+		printf("Error: PMIC read failed\n");
+		goto default_config;
+	} else {
+		if (reg == 0x05) {
+			config->ram = M2_RAM_MT47H128M16RT25E;	/* set DDR2 */
+			printf("DDR2 detected\n");
+		} else if (reg == 0x01) {
+			config->ram = M2_RAM_K4B2G1646EBIH9;	/* set legacy DDR3 */
+			printf("DDR3 detected\n");
+		} else {
+			goto default_config;
+		}
+	}
+
+	return;
+
+default_config:
+#endif
+
+	config->ram = M2_RAM_K4B2G1646EBIH9;	/* set default to legacy DDR3 */
+	printf("Error: no RAM configuration found, trying fallback configuration %u\n", config->ram);
+}
diff --git a/board/bytesatwork/byteengine_am335x/m2config/m2config_get.h b/board/bytesatwork/byteengine_am335x/m2config/m2config_get.h
new file mode 100644
index 0000000000..bca128fb05
--- /dev/null
+++ b/board/bytesatwork/byteengine_am335x/m2config/m2config_get.h
@@ -0,0 +1,13 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2015 bytes at work AG
+ */
+
+#ifndef M2CONFIG_GET_H
+#define M2CONFIG_GET_H
+
+#include "m2config.h"
+
+void m2config_get(struct m2config *config);
+
+#endif
diff --git a/board/bytesatwork/byteengine_am335x/mux.c b/board/bytesatwork/byteengine_am335x/mux.c
new file mode 100644
index 0000000000..a1aa777fc8
--- /dev/null
+++ b/board/bytesatwork/byteengine_am335x/mux.c
@@ -0,0 +1,144 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2018 bytes at work AG
+ *
+ * Based on board/ti/am335x/mux.c
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ */
+
+#include <common.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/mux.h>
+#include <asm/io.h>
+#include <i2c.h>
+#include "board.h"
+
+static struct module_pin_mux uart0_pin_mux[] = {
+	{OFFSET(uart0_rxd), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* UART0_RXD */
+	{OFFSET(uart0_txd), (MODE(0) | PULLUDEN)},		/* UART0_TXD */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_pin_mux[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{-1},
+};
+
+#ifdef CONFIG_SPI_FLASH
+static struct module_pin_mux mmc1_pin_mux[] = {
+	{OFFSET(gpmc_ad7), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT7 */
+	{OFFSET(gpmc_ad6), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT6 */
+	{OFFSET(gpmc_ad5), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT5 */
+	{OFFSET(gpmc_ad4), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT4 */
+	{OFFSET(gpmc_ad3), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT3 */
+	{OFFSET(gpmc_ad2), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT2 */
+	{OFFSET(gpmc_ad1), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT1 */
+	{OFFSET(gpmc_ad0), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT0 */
+	{OFFSET(gpmc_csn1), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CLK */
+	{OFFSET(gpmc_csn2), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CMD */
+	{-1},
+};
+#else
+static struct module_pin_mux nand_pin_mux[] = {
+	{OFFSET(gpmc_ad0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* GPMC_AD0 */
+	{OFFSET(gpmc_ad1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* GPMC_AD1 */
+	{OFFSET(gpmc_ad2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* GPMC_AD2 */
+	{OFFSET(gpmc_ad3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* GPMC_AD3 */
+	{OFFSET(gpmc_ad4), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* GPMC_AD4 */
+	{OFFSET(gpmc_ad5), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* GPMC_AD5 */
+	{OFFSET(gpmc_ad6), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* GPMC_AD6 */
+	{OFFSET(gpmc_ad7), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* GPMC_AD7 */
+	{OFFSET(gpmc_wpn), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* GPMC_WPN */
+	{OFFSET(gpmc_csn0), (MODE(0))},				/* GPMC_CSN0 */
+	{OFFSET(gpmc_advn_ale), (MODE(0))},			/* GPMC_ADVN_ALE */
+	{OFFSET(gpmc_be0n_cle), (MODE(0))},			/* GPMC_BEN0_CLE */
+	{OFFSET(gpmc_wen), (MODE(0))},				/* GPMC_WEN */
+	{OFFSET(gpmc_oen_ren), (MODE(0))},			/* GPMC_OEN_REN */
+	{OFFSET(gpmc_wait0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* GPMC_WAIT0 */
+	{-1},
+};
+#endif
+
+static struct module_pin_mux i2c0_pin_mux[] = {
+	{OFFSET(i2c0_sda), (MODE(0) | RXACTIVE | PULLUDEN | SLEWCTRL)},	/* I2C_DATA */
+	{OFFSET(i2c0_scl), (MODE(0) | RXACTIVE | PULLUDEN | SLEWCTRL)},	/* I2C_SCLK */
+	{-1},
+};
+
+static struct module_pin_mux mii1_pin_mux[] = {
+	{OFFSET(mii1_txen), MODE(2)},			/* MII1_TXEN */
+	{OFFSET(mii1_rxdv), MODE(2) | RXACTIVE},	/* MII1_RXDV */
+	{OFFSET(mii1_txd3), MODE(2)},			/* MII1_TXD3 */
+	{OFFSET(mii1_txd2), MODE(2)},			/* MII1_TXD2 */
+	{OFFSET(mii1_txd1), MODE(2)},			/* MII1_TXD1 */
+	{OFFSET(mii1_txd0), MODE(2)},			/* MII1_TXD0 */
+	{OFFSET(mii1_txclk), MODE(2)},			/* MII1_TXCLK */
+	{OFFSET(mii1_rxclk), MODE(2) | RXACTIVE},	/* MII1_RXCLK */
+	{OFFSET(mii1_rxd3), MODE(2) | RXACTIVE},	/* MII1_RXD3 */
+	{OFFSET(mii1_rxd2), MODE(2) | RXACTIVE},	/* MII1_RXD2 */
+	{OFFSET(mii1_rxd1), MODE(2) | RXACTIVE},	/* MII1_RXD1 */
+	{OFFSET(mii1_rxd0), MODE(2) | RXACTIVE},	/* MII1_RXD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN},	/* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},		/* MDIO_CLK */
+	{OFFSET(uart1_rtsn), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* PHY Reset */
+	{OFFSET(gpmc_ad11), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* PHY INT */
+	{-1},
+};
+
+#ifdef CONFIG_SPI_FLASH
+static struct module_pin_mux spi0_pin_mux[] = {
+	{OFFSET(spi0_sclk), (MODE(0) | RXACTIVE | PULLUDEN)},			/* SPI0_SCLK */
+	{OFFSET(spi0_d0), (MODE(0) | RXACTIVE | PULLUDEN | PULLUP_EN)},		/* SPI0_D0 */
+	{OFFSET(spi0_d1), (MODE(0) | RXACTIVE | PULLUDEN)},			/* SPI0_D1 */
+	{OFFSET(spi0_cs0), (MODE(0) | RXACTIVE | PULLUDEN | PULLUP_EN)},	/* SPI0_CS0 */
+	{-1},
+};
+#endif
+
+/* GPIO Muxing for Production Test */
+static struct module_pin_mux gpio_pin_mux[] = {
+	{OFFSET(gpmc_ad14), (MODE(7) | RXACTIVE)},
+	{OFFSET(gpmc_ad12), (MODE(7) | RXACTIVE)},
+	{OFFSET(gpmc_ad13), (MODE(7) | RXACTIVE)},
+	{OFFSET(gpmc_ad10), (MODE(7) | RXACTIVE)},
+	{OFFSET(gpmc_ad9), (MODE(7) | RXACTIVE)},
+	{OFFSET(gpmc_ad8), (MODE(7) | RXACTIVE)},
+	{OFFSET(uart1_ctsn), (MODE(7) | RXACTIVE)},
+	{OFFSET(emu0), (MODE(7) | RXACTIVE)},
+	{OFFSET(emu1), (MODE(7) | RXACTIVE)},
+	{OFFSET(spi0_cs1), (MODE(7) | RXACTIVE)},
+	{OFFSET(mcasp0_aclkx), (MODE(7) | RXACTIVE)},
+	{OFFSET(uart0_ctsn), (MODE(7) | RXACTIVE)},
+	{-1},
+};
+
+void enable_uart0_pin_mux(void)
+{
+	configure_module_pin_mux(uart0_pin_mux);
+}
+
+void enable_i2c0_pin_mux(void)
+{
+	configure_module_pin_mux(i2c0_pin_mux);
+}
+
+void enable_board_pin_mux(void)
+{
+	configure_module_pin_mux(mii1_pin_mux);
+	configure_module_pin_mux(mmc0_pin_mux);
+	configure_module_pin_mux(gpio_pin_mux);
+
+#ifdef CONFIG_SPI_FLASH
+	configure_module_pin_mux(spi0_pin_mux);
+	configure_module_pin_mux(mmc1_pin_mux);
+#else
+	configure_module_pin_mux(nand_pin_mux);
+#endif
+}
diff --git a/board/bytesatwork/byteengine_am335x/ram.c b/board/bytesatwork/byteengine_am335x/ram.c
new file mode 100644
index 0000000000..2db217d1b5
--- /dev/null
+++ b/board/bytesatwork/byteengine_am335x/ram.c
@@ -0,0 +1,356 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * RAM initialization for byteENGINE AM335x
+ *
+ * Copyright (C) 2015 bytes at work AG
+ */
+
+#include <asm/arch/ddr_defs.h>
+#include <asm/arch-am33xx/clock.h>
+#include <i2c.h>
+#include <config.h>
+#include "board.h"
+#include "ddr_defs_baw.h"
+#include "m2config/m2config.h"
+#include "m2config/m2config_get.h"
+#include "m2config/m2config_eeprom.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define OSC	(V_OSCK / 1000000)
+
+/* 256 MB DDR2 ------------------------------------------------------------- */
+
+static const struct ctrl_ioregs MT47H128M16RT25E_ctrl_ioregs = {
+	.cm0ioctl		= MT47H128M16RT25E_IOCTRL_VALUE,
+	.cm1ioctl		= MT47H128M16RT25E_IOCTRL_VALUE,
+	.cm2ioctl		= MT47H128M16RT25E_IOCTRL_VALUE,
+	.dt0ioctl		= MT47H128M16RT25E_IOCTRL_VALUE,
+	.dt1ioctl		= MT47H128M16RT25E_IOCTRL_VALUE,
+};
+
+static const struct ddr_data MT47H128M16RT25E_ddr_data = {
+	.datardsratio0		= MT47H128M16RT25E_RD_DQS,
+	.datafwsratio0		= MT47H128M16RT25E_PHY_FIFO_WE,
+	.datawrsratio0		= MT47H128M16RT25E_PHY_WR_DATA,
+};
+
+static const struct cmd_control MT47H128M16RT25E_cmd_control = {
+	.cmd0csratio		= MT47H128M16RT25E_RATIO,
+	.cmd1csratio		= MT47H128M16RT25E_RATIO,
+	.cmd2csratio		= MT47H128M16RT25E_RATIO,
+};
+
+static const struct emif_regs MT47H128M16RT25E_emif_regs = {
+	.sdram_config		= MT47H128M16RT25E_EMIF_SDCFG,
+	.ref_ctrl		= MT47H128M16RT25E_EMIF_SDREF,
+	.sdram_tim1		= MT47H128M16RT25E_EMIF_TIM1,
+	.sdram_tim2		= MT47H128M16RT25E_EMIF_TIM2,
+	.sdram_tim3		= MT47H128M16RT25E_EMIF_TIM3,
+	.emif_ddr_phy_ctlr_1	= MT47H128M16RT25E_EMIF_READ_LATENCY,
+};
+
+#define MT47H128M16RT25E_CLOCK_MHZ	266
+
+static void init_MT47H128M16RT25E(void)
+{
+	config_ddr(MT47H128M16RT25E_CLOCK_MHZ,
+		   &MT47H128M16RT25E_ctrl_ioregs,
+		   &MT47H128M16RT25E_ddr_data,
+		   &MT47H128M16RT25E_cmd_control,
+		   &MT47H128M16RT25E_emif_regs,
+		   0);
+}
+
+static const struct dpll_params MT47H128M16RT25E_dpll = {
+	MT47H128M16RT25E_CLOCK_MHZ, OSC - 1,
+	1, -1, -1, -1, -1
+};
+
+/* DDR3 256 and 512 MB Legacy setting due to wrong programmed modules config 2 */
+
+static const struct ctrl_ioregs K4B2G1646EBIH9_ctrl_ioregs = {
+	.cm0ioctl               = K4B2G1646EBIH9_IOCTRL_VALUE,
+	.cm1ioctl               = K4B2G1646EBIH9_IOCTRL_VALUE,
+	.cm2ioctl               = K4B2G1646EBIH9_IOCTRL_VALUE,
+	.dt0ioctl               = K4B2G1646EBIH9_IOCTRL_VALUE,
+	.dt1ioctl               = K4B2G1646EBIH9_IOCTRL_VALUE,
+};
+
+static const struct ddr_data K4B2G1646EBIH9_ddr_data = {
+	.datardsratio0		= K4B2G1646EBIH9_RD_DQS,
+	.datawdsratio0		= K4B2G1646EBIH9_WR_DQS,
+	.datafwsratio0		= K4B2G1646EBIH9_PHY_FIFO_WE,
+	.datawrsratio0		= K4B2G1646EBIH9_PHY_WR_DATA,
+};
+
+static const struct cmd_control K4B2G1646EBIH9_cmd_control = {
+	.cmd0csratio		= K4B2G1646EBIH9_RATIO,
+	.cmd0iclkout		= K4B2G1646EBIH9_INVERT_CLKOUT,
+
+	.cmd1csratio		= K4B2G1646EBIH9_RATIO,
+	.cmd1iclkout		= K4B2G1646EBIH9_INVERT_CLKOUT,
+
+	.cmd2csratio		= K4B2G1646EBIH9_RATIO,
+	.cmd2iclkout		= K4B2G1646EBIH9_INVERT_CLKOUT,
+};
+
+static const struct emif_regs K4B2G1646EBIH9_emif_regs = {
+	.sdram_config		= K4B2G1646EBIH9_EMIF_SDCFG,
+	.ref_ctrl		= K4B2G1646EBIH9_EMIF_SDREF,
+	.sdram_tim1		= K4B2G1646EBIH9_EMIF_TIM1,
+	.sdram_tim2		= K4B2G1646EBIH9_EMIF_TIM2,
+	.sdram_tim3		= K4B2G1646EBIH9_EMIF_TIM3,
+	.zq_config		= K4B2G1646EBIH9_ZQ_CFG,
+	.emif_ddr_phy_ctlr_1	= K4B2G1646EBIH9_EMIF_READ_LATENCY,
+};
+
+#define K4B2G1646EBIH9_CLOCK_MHZ	303
+
+static void init_K4B2G1646EBIH9(void)
+{
+	config_ddr(K4B2G1646EBIH9_CLOCK_MHZ,
+		   &K4B2G1646EBIH9_ctrl_ioregs,
+		   &K4B2G1646EBIH9_ddr_data,
+		   &K4B2G1646EBIH9_cmd_control,
+		   &K4B2G1646EBIH9_emif_regs,
+		   0);
+
+	mdelay(2);
+}
+
+static const struct dpll_params K4B2G1646EBIH9_dpll = {
+	K4B2G1646EBIH9_CLOCK_MHZ, OSC - 1,
+	1, -1, -1, -1, -1
+};
+
+/* DDR3 256 MB K4B2G1646Q-BCK0 --------------------------------------------- */
+
+static const struct ctrl_ioregs K4B2G1646QBCK0_ctrl_ioregs = {
+	.cm0ioctl               = K4B2G1646QBCK0_IOCTRL_VALUE,
+	.cm1ioctl               = K4B2G1646QBCK0_IOCTRL_VALUE,
+	.cm2ioctl               = K4B2G1646QBCK0_IOCTRL_VALUE,
+	.dt0ioctl               = K4B2G1646QBCK0_IOCTRL_VALUE,
+	.dt1ioctl               = K4B2G1646QBCK0_IOCTRL_VALUE,
+};
+
+static const struct ddr_data K4B2G1646QBCK0_ddr_data = {
+	.datardsratio0		= K4B2G1646QBCK0_RD_DQS,
+	.datawdsratio0		= K4B2G1646QBCK0_WR_DQS,
+	.datafwsratio0		= K4B2G1646QBCK0_PHY_FIFO_WE,
+	.datawrsratio0		= K4B2G1646QBCK0_PHY_WR_DATA,
+};
+
+static const struct cmd_control K4B2G1646QBCK0_cmd_control = {
+	.cmd0csratio		= K4B2G1646QBCK0_RATIO,
+	.cmd0iclkout		= K4B2G1646QBCK0_INVERT_CLKOUT,
+
+	.cmd1csratio		= K4B2G1646QBCK0_RATIO,
+	.cmd1iclkout		= K4B2G1646QBCK0_INVERT_CLKOUT,
+
+	.cmd2csratio		= K4B2G1646QBCK0_RATIO,
+	.cmd2iclkout		= K4B2G1646QBCK0_INVERT_CLKOUT,
+};
+
+static const struct emif_regs K4B2G1646QBCK0_emif_regs = {
+	.sdram_config		= K4B2G1646QBCK0_EMIF_SDCFG,
+	.ref_ctrl		= K4B2G1646QBCK0_EMIF_SDREF,
+	.sdram_tim1		= K4B2G1646QBCK0_EMIF_TIM1,
+	.sdram_tim2		= K4B2G1646QBCK0_EMIF_TIM2,
+	.sdram_tim3		= K4B2G1646QBCK0_EMIF_TIM3,
+	.zq_config		= K4B2G1646QBCK0_ZQ_CFG,
+	.emif_ddr_phy_ctlr_1	= K4B2G1646QBCK0_EMIF_READ_LATENCY,
+};
+
+#define K4B2G1646QBCK0_CLOCK_MHZ	400
+
+static void init_K4B2G1646QBCK0(void)
+{
+	config_ddr(K4B2G1646QBCK0_CLOCK_MHZ,
+		   &K4B2G1646QBCK0_ctrl_ioregs,
+		   &K4B2G1646QBCK0_ddr_data,
+		   &K4B2G1646QBCK0_cmd_control,
+		   &K4B2G1646QBCK0_emif_regs,
+		   0);
+
+	mdelay(2);
+}
+
+static const struct dpll_params K4B2G1646QBCK0_dpll = {
+	K4B2G1646QBCK0_CLOCK_MHZ, OSC - 1,
+	1, -1, -1, -1, -1
+};
+
+/* DDR3 512MB K4B4G1646D --------------------------------------------------- */
+static const struct ctrl_ioregs K4B4G1646DBIK0_ctrl_ioregs = {
+	.cm0ioctl               = K4B4G1646DBIK0_IOCTRL_VALUE,
+	.cm1ioctl               = K4B4G1646DBIK0_IOCTRL_VALUE,
+	.cm2ioctl               = K4B4G1646DBIK0_IOCTRL_VALUE,
+	.dt0ioctl               = K4B4G1646DBIK0_IOCTRL_VALUE,
+	.dt1ioctl               = K4B4G1646DBIK0_IOCTRL_VALUE,
+};
+
+static const struct ddr_data K4B4G1646DBIK0_ddr_data = {
+	.datardsratio0		= K4B4G1646DBIK0_RD_DQS,
+	.datawdsratio0		= K4B4G1646DBIK0_WR_DQS,
+	.datafwsratio0		= K4B4G1646DBIK0_PHY_FIFO_WE,
+	.datawrsratio0		= K4B4G1646DBIK0_PHY_WR_DATA,
+};
+
+static const struct cmd_control K4B4G1646DBIK0_cmd_control = {
+	.cmd0csratio		= K4B4G1646DBIK0_RATIO,
+	.cmd0iclkout		= K4B4G1646DBIK0_INVERT_CLKOUT,
+
+	.cmd1csratio		= K4B4G1646DBIK0_RATIO,
+	.cmd1iclkout		= K4B4G1646DBIK0_INVERT_CLKOUT,
+
+	.cmd2csratio		= K4B4G1646DBIK0_RATIO,
+	.cmd2iclkout		= K4B4G1646DBIK0_INVERT_CLKOUT,
+};
+
+static const struct emif_regs K4B4G1646DBIK0_emif_regs = {
+	.sdram_config		= K4B4G1646DBIK0_EMIF_SDCFG,
+	.ref_ctrl		= K4B4G1646DBIK0_EMIF_SDREF,
+	.sdram_tim1		= K4B4G1646DBIK0_EMIF_TIM1,
+	.sdram_tim2		= K4B4G1646DBIK0_EMIF_TIM2,
+	.sdram_tim3		= K4B4G1646DBIK0_EMIF_TIM3,
+	.zq_config		= K4B4G1646DBIK0_ZQ_CFG,
+	.emif_ddr_phy_ctlr_1	= K4B4G1646DBIK0_EMIF_READ_LATENCY,
+};
+
+#define K4B4G1646DBIK0_CLOCK_MHZ	400
+
+static void init_K4B4G1646DBIK0(void)
+{
+	config_ddr(K4B4G1646DBIK0_CLOCK_MHZ,
+		   &K4B4G1646DBIK0_ctrl_ioregs,
+		   &K4B4G1646DBIK0_ddr_data,
+		   &K4B4G1646DBIK0_cmd_control,
+		   &K4B4G1646DBIK0_emif_regs,
+		   0);
+
+	mdelay(2);
+}
+
+static const struct dpll_params K4B4G1646DBIK0_dpll = {
+	K4B4G1646DBIK0_CLOCK_MHZ, OSC - 1,
+	1, -1, -1, -1, -1
+};
+
+/* DDR3 1024MB MT41K512M16HA-107 IT:A 	D9SGD -------------------------------*/
+
+static const struct ctrl_ioregs MT41K512M16HA107_ctrl_ioregs = {
+	.cm0ioctl               = MT41K512M16HA107_IOCTRL_VALUE,
+	.cm1ioctl               = MT41K512M16HA107_IOCTRL_VALUE,
+	.cm2ioctl               = MT41K512M16HA107_IOCTRL_VALUE,
+	.dt0ioctl               = MT41K512M16HA107_IOCTRL_VALUE,
+	.dt1ioctl               = MT41K512M16HA107_IOCTRL_VALUE,
+};
+
+static const struct ddr_data MT41K512M16HA107_ddr_data = {
+	.datardsratio0		= MT41K512M16HA107_RD_DQS,
+	.datawdsratio0		= MT41K512M16HA107_WR_DQS,
+	.datafwsratio0		= MT41K512M16HA107_PHY_FIFO_WE,
+	.datawrsratio0		= MT41K512M16HA107_PHY_WR_DATA,
+};
+
+static const struct cmd_control MT41K512M16HA107_cmd_control = {
+	.cmd0csratio		= MT41K512M16HA107_RATIO,
+	.cmd0iclkout		= MT41K512M16HA107_INVERT_CLKOUT,
+
+	.cmd1csratio		= MT41K512M16HA107_RATIO,
+	.cmd1iclkout		= MT41K512M16HA107_INVERT_CLKOUT,
+
+	.cmd2csratio		= MT41K512M16HA107_RATIO,
+	.cmd2iclkout		= MT41K512M16HA107_INVERT_CLKOUT,
+};
+
+static const struct emif_regs MT41K512M16HA107_emif_regs = {
+	.sdram_config		= MT41K512M16HA107_EMIF_SDCFG,
+	.ref_ctrl		= MT41K512M16HA107_EMIF_SDREF,
+	.sdram_tim1		= MT41K512M16HA107_EMIF_TIM1,
+	.sdram_tim2		= MT41K512M16HA107_EMIF_TIM2,
+	.sdram_tim3		= MT41K512M16HA107_EMIF_TIM3,
+	.zq_config		= MT41K512M16HA107_ZQ_CFG,
+	.emif_ddr_phy_ctlr_1	= MT41K512M16HA107_EMIF_READ_LATENCY,
+};
+
+#define MT41K512M16HA107_CLOCK_MHZ 303
+
+static void init_MT41K512M16HA107(void)
+{
+	config_ddr(MT41K512M16HA107_CLOCK_MHZ,
+		   &MT41K512M16HA107_ctrl_ioregs,
+		   &MT41K512M16HA107_ddr_data,
+		   &MT41K512M16HA107_cmd_control,
+		   &MT41K512M16HA107_emif_regs,
+		   0);
+
+	mdelay(2);
+}
+
+static const struct dpll_params MT41K512M16HA107_dpll = {
+	MT41K512M16HA107_CLOCK_MHZ, OSC - 1,
+	1, -1, -1, -1, -1
+};
+
+/* ------------------------------------------------------------------------- */
+
+struct ram_config {
+	m2config_ram_t	config;
+	void (*init)(void);
+	const struct dpll_params *dpll_param;
+};
+
+const struct ram_config ram_init_map[] = {
+	{ M2_RAM_MT47H128M16RT25E, init_MT47H128M16RT25E, &MT47H128M16RT25E_dpll },
+	{ M2_RAM_K4B2G1646EBIH9, init_K4B2G1646EBIH9, &K4B2G1646EBIH9_dpll },
+	{ M2_RAM_K4B2G1646QBCK0, init_K4B2G1646QBCK0, &K4B2G1646QBCK0_dpll },
+	{ M2_RAM_K4B4G1646DBIK0, init_K4B4G1646DBIK0, &K4B4G1646DBIK0_dpll },
+	{ M2_RAM_MT41K512M16HA107, init_MT41K512M16HA107, &MT41K512M16HA107_dpll },
+	{ -1, NULL }
+};
+
+static const struct ram_config *find_ram(m2config_ram_t config)
+{
+	const struct ram_config *itr;
+
+	for (itr = ram_init_map; itr->init; itr++)
+		if (itr->config == config)
+			return itr;
+
+	return NULL;
+}
+
+static const struct ram_config *getRam(void)
+{
+	const struct ram_config *ram = NULL;
+	struct m2config config;
+
+	m2config_get(&config);
+	ram = find_ram(config.ram);
+
+	return ram;
+}
+
+void sdram_init(void)
+{
+	const struct ram_config *ram = getRam();
+
+	ram->init();
+
+	/* Set OCP_CONFIG (fix LCD pixel shift during operation) */
+	writel(EMIF_OCP_CONFIG_BYTEENGINE_AM335X, EMIF_OCP_CONFIG);
+}
+
+const struct dpll_params *get_dpll_ddr_params(void)
+{
+	enable_i2c0_pin_mux();
+#ifndef CONFIG_DM_I2C
+	i2c_init(CONFIG_SYS_OMAP24_I2C_SPEED, CONFIG_SYS_OMAP24_I2C_SLAVE);
+#endif
+
+	const struct ram_config *ram = getRam();
+
+	return ram->dpll_param;
+}
diff --git a/board/bytesatwork/byteengine_am335x/u-boot.lds b/board/bytesatwork/byteengine_am335x/u-boot.lds
new file mode 100644
index 0000000000..a1494b9308
--- /dev/null
+++ b/board/bytesatwork/byteengine_am335x/u-boot.lds
@@ -0,0 +1,131 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (c) 2004-2008 Texas Instruments
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text :
+	{
+		*(.__image_copy_start)
+		*(.vectors)
+		CPUDIR/start.o (.text*)
+		board/bytesatwork/byteengine_am335x/built-in.o (.text*)
+		*(.text*)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
+
+	. = ALIGN(4);
+	.data : {
+		*(.data*)
+	}
+
+	. = ALIGN(4);
+
+	. = .;
+
+	. = ALIGN(4);
+	.u_boot_list : {
+		KEEP(*(SORT(.u_boot_list*)));
+	}
+
+	. = ALIGN(4);
+
+	.efi_runtime_rel_start :
+	{
+		*(.__efi_runtime_rel_start)
+	}
+
+	.efi_runtime_rel : {
+		*(.rel*.efi_runtime)
+		*(.rel*.efi_runtime.*)
+	}
+
+	.efi_runtime_rel_stop :
+	{
+		*(.__efi_runtime_rel_stop)
+	}
+
+	. = ALIGN(4);
+
+	.image_copy_end :
+	{
+		*(.__image_copy_end)
+	}
+
+	.rel_dyn_start :
+	{
+		*(.__rel_dyn_start)
+	}
+
+	.rel.dyn : {
+		*(.rel*)
+	}
+
+	.rel_dyn_end :
+	{
+		*(.__rel_dyn_end)
+	}
+
+	.hash : { *(.hash*) }
+
+	.end :
+	{
+		*(.__end)
+	}
+
+	_image_binary_end = .;
+
+	/*
+	 * Deprecated: this MMU section is used by pxa at present but
+	 * should not be used by new boards/CPUs.
+	 */
+	. = ALIGN(4096);
+	.mmutable : {
+		*(.mmutable)
+	}
+
+/*
+ * Compiler-generated __bss_start and __bss_end, see arch/arm/lib/bss.c
+ * __bss_base and __bss_limit are for linker only (overlay ordering)
+ */
+
+	.bss_start __rel_dyn_start (OVERLAY) : {
+		KEEP(*(.__bss_start));
+		__bss_base = .;
+	}
+
+	.bss __bss_base (OVERLAY) : {
+		*(.bss*)
+		 . = ALIGN(4);
+		 __bss_limit = .;
+	}
+
+	.bss_end __bss_limit (OVERLAY) : {
+		KEEP(*(.__bss_end));
+	}
+
+	.dynsym _image_binary_end : { *(.dynsym) }
+	.dynbss : { *(.dynbss) }
+	.dynstr : { *(.dynstr*) }
+	.dynamic : { *(.dynamic*) }
+	.gnu.hash : { *(.gnu.hash) }
+	.plt : { *(.plt*) }
+	.interp : { *(.interp*) }
+	.gnu : { *(.gnu*) }
+	.ARM.exidx : { *(.ARM.exidx*) }
+}
diff --git a/configs/am335x_bytedevkit_emmc_defconfig b/configs/am335x_bytedevkit_emmc_defconfig
new file mode 100644
index 0000000000..b6089c76f9
--- /dev/null
+++ b/configs/am335x_bytedevkit_emmc_defconfig
@@ -0,0 +1,65 @@
+CONFIG_ARM=y
+CONFIG_ARCH_OMAP2PLUS=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_AM33XX=y
+CONFIG_TARGET_BYTEENGINE_AM335X=y
+CONFIG_SPL_MMC_SUPPORT=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_SPL=y
+CONFIG_SPL_FAT_SUPPORT=y
+CONFIG_SPL_LIBDISK_SUPPORT=y
+CONFIG_SPL_SPI_FLASH_SUPPORT=y
+CONFIG_SPL_SPI_SUPPORT=y
+CONFIG_SPI_BOOT=y
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_SPL_I2C_SUPPORT=y
+# CONFIG_SPL_NAND_SUPPORT is not set
+CONFIG_SPL_POWER_SUPPORT=y
+CONFIG_SPL_WATCHDOG_SUPPORT=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_CPUINFO=y
+CONFIG_CMD_MEMINFO=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_PXE=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_CMD_MTDPARTS=y
+CONFIG_OF_CONTROL=y
+CONFIG_DEFAULT_DEVICE_TREE="am335x-bytedevkit-emmc"
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_OMAP_HS=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_SFDP_SUPPORT=y
+CONFIG_SPI_FLASH_ATMEL=y
+CONFIG_SPI_FLASH_EON=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_ISSI=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_SPI_FLASH_XMC=y
+CONFIG_PHY_TI=y
+CONFIG_DM_ETH=y
+CONFIG_MII=y
+CONFIG_DRIVER_TI_CPSW=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_OMAP3_SPI=y
+CONFIG_TIMER=y
+CONFIG_OMAP_TIMER=y
+# CONFIG_EFI_LOADER is not set
diff --git a/configs/am335x_bytedevkit_nand_defconfig b/configs/am335x_bytedevkit_nand_defconfig
new file mode 100644
index 0000000000..15c5bd1fe3
--- /dev/null
+++ b/configs/am335x_bytedevkit_nand_defconfig
@@ -0,0 +1,52 @@
+CONFIG_ARM=y
+CONFIG_ARCH_OMAP2PLUS=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_AM33XX=y
+CONFIG_TARGET_BYTEENGINE_AM335X=y
+CONFIG_SPL_MMC_SUPPORT=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_SPL=y
+CONFIG_SPL_FAT_SUPPORT=y
+CONFIG_SPL_LIBDISK_SUPPORT=y
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_SPL_I2C_SUPPORT=y
+CONFIG_SPL_POWER_SUPPORT=y
+CONFIG_SPL_WATCHDOG_SUPPORT=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_CPUINFO=y
+CONFIG_CMD_MEMINFO=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_NAND=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_PXE=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_CMD_MTDPARTS=y
+CONFIG_MTDIDS_DEFAULT="nand0=8000000.nand"
+CONFIG_MTDPARTS_DEFAULT="mtdparts=8000000.nand:128k(NAND.SPL),128k(NAND.SPL.backup1),128k(NAND.SPL.backup2),128k(NAND.SPL.backup3),256k(NAND.u-boot-spl-os),1m(NAND.u-boot),128k(NAND.u-boot-env),128k(NAND.u-boot-env.backup1),8m(NAND.kernel),-(NAND.file-system)"
+CONFIG_OF_CONTROL=y
+CONFIG_DEFAULT_DEVICE_TREE="am335x-bytedevkit-nand"
+CONFIG_ENV_IS_IN_NAND=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_OMAP_HS=y
+CONFIG_NAND=y
+CONFIG_PHY_TI=y
+CONFIG_DM_ETH=y
+CONFIG_MII=y
+CONFIG_DRIVER_TI_CPSW=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_OMAP3_SPI=y
+CONFIG_TIMER=y
+CONFIG_OMAP_TIMER=y
+# CONFIG_EFI_LOADER is not set
diff --git a/include/configs/byteengine_am335x.h b/include/configs/byteengine_am335x.h
new file mode 100644
index 0000000000..d75406c67b
--- /dev/null
+++ b/include/configs/byteengine_am335x.h
@@ -0,0 +1,270 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2015 bytes at work AG
+ *
+ * Based on am335x_evm.h
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ */
+
+#ifndef BYTEENGINE_AM335X_H
+#define BYTEENGINE_AM335X_H
+
+#include <configs/ti_am335x_common.h>
+#include <linux/sizes.h>
+
+#ifndef CONFIG_SPL_BUILD
+# define CONFIG_TIMESTAMP
+#endif
+
+#define CONFIG_SYS_BOOTM_LEN		SZ_16M
+
+/* Clock Defines */
+#define V_OSCK				24000000 /* Clock output from T2 */
+#define V_SCLK				(V_OSCK)
+
+#define M2CONFIG_BUILTIN_PCB	M2_PCB_REV_02
+#define M2CONFIG_BUILTIN_RAM	M2_RAM_K4B2G1646EBIH9
+#define M2CONFIG_BUILTIN_FLASH	M2_NAND_2GBIT
+
+/* NS16550 Configuration */
+#define CONFIG_SYS_NS16550_COM1		0x44e09000	/* UART0 */
+#define CONFIG_SYS_NS16550_COM2		0x48022000	/* UART1 */
+#define CONFIG_SYS_NS16550_COM3		0x48024000	/* UART2 */
+#define CONFIG_SYS_NS16550_COM4		0x481a6000	/* UART3 */
+#define CONFIG_SYS_NS16550_COM5		0x481a8000	/* UART4 */
+#define CONFIG_SYS_NS16550_COM6		0x481aa000	/* UART5 */
+
+/* PMIC support */
+#define CONFIG_POWER_TPS65910
+
+/* Network */
+#define CONFIG_PHY_ADDR			1
+
+/*
+ * Disable MMC DM for SPL build, it can be re-enabled after adding
+ * DM support in SPL
+ */
+#ifdef CONFIG_SPL_BUILD
+#undef CONFIG_DM_MMC
+#undef CONFIG_TIMER
+#undef CONFIG_DM_USB
+#endif
+
+#ifdef CONFIG_NAND
+#define BOOT_ENV_SETTINGS	NAND_BOOT_ENV_SETTINGS
+#define CONFIG_BOOTCOMMAND \
+	"if mmc rescan; then " \
+		"echo SD/MMC found on device ${mmc_dev}; " \
+		"run nand_update; " \
+		"run mmc_boot; " \
+	"else " \
+		"run nand_boot; " \
+	"fi; "
+#else
+#define BOOT_ENV_SETTINGS	MMC_BOOT_ENV_SETTINGS
+#define CONFIG_BOOTCOMMAND \
+	"if mmc rescan; then " \
+		"echo SD/MMC found on device ${mmc_dev}; " \
+		"run mmc_boot; " \
+	"else " \
+		"run emmc_boot; " \
+	"fi; "
+#endif
+
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	BOOT_ENV_SETTINGS \
+	"mlofile=MLO\0" \
+	"ubootfile=u-boot.img\0" \
+	"kernelfile=uImage\0" \
+	"dtbfile=devtree.dtb\0" \
+	"fdt_high=0xffffffff\0" \
+	"loadaddr=0x82000000\0" \
+	"dtbaddr=0x83000000\0" \
+	"console=ttyO0,115200n8\0" \
+	"mmc_root=/dev/mmcblk0p2\0" \
+	"mmc_args=setenv bootargs " \
+		"console=${console} " \
+		"vt.global_cursor_default=0 " \
+		"${mtd_parts} " \
+		"root=${mmc_root} " \
+		"rootwait " \
+		"consoleblank=0 " \
+		"; " \
+	"\0" \
+	"mmc_boot=echo Booting from mmc ...; " \
+		"run mmc_args; " \
+		"load mmc 0 ${loadaddr} ${kernelfile} || exit; " \
+		"load mmc 0 ${dtbaddr} ${dtbfile} || exit; " \
+		"bootm ${loadaddr} - ${dtbaddr}; " \
+	"\0"
+
+#endif
+
+#ifdef CONFIG_NAND
+
+/* NAND: device related configs */
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_PAGE_COUNT	(CONFIG_SYS_NAND_BLOCK_SIZE / \
+					 CONFIG_SYS_NAND_PAGE_SIZE)
+#define CONFIG_SYS_NAND_PAGE_SIZE	2048
+#define CONFIG_SYS_NAND_OOBSIZE		64
+#define CONFIG_SYS_NAND_BLOCK_SIZE	SZ_128K
+/* NAND: driver related configs */
+#define CONFIG_SYS_NAND_BAD_BLOCK_POS	NAND_LARGE_BADBLOCK_POS
+#define CONFIG_SYS_NAND_ECCPOS		{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
+
+#define CONFIG_SYS_NAND_ECCSIZE		512
+#define CONFIG_SYS_NAND_ECCBYTES	3
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+#define CONFIG_NAND_OMAP_ECCSCHEME	OMAP_ECC_HAM1_CODE_HW
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	0x00080000
+/* NAND: SPL related configs */
+
+#define MTDPARTS_DEFAULT		"mtdparts=omap2-nand.0:128k(SPL)," \
+					"128k(SPL.backup1)," \
+					"128k(SPL.backup2)," \
+					"128k(SPL.backup3),1920k(u-boot)," \
+					"128k(u-boot-env),512k(devtree),5m(kernel),-(rootfs)"
+
+#ifdef CONFIG_ENV_IS_IN_NAND
+#define CONFIG_ENV_OFFSET		0x260000
+#define CONFIG_ENV_SIZE			SZ_128K
+#define CONFIG_SYS_ENV_SECT_SIZE	CONFIG_SYS_NAND_BLOCK_SIZE
+#else
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#define CONFIG_ENV_OFFSET		SZ_128K
+#define CONFIG_ENV_SIZE			SZ_8K
+#endif
+
+#define NAND_BOOT_ENV_SETTINGS \
+	"mtd_parts=" MTDPARTS_DEFAULT "\0" \
+	"nand_root=/dev/mtdblock8\0" \
+	"nand_root_fs_type=jffs2\0" \
+	"nand_spl_addr=   0x00000000\0" \
+	"nand_spl_size=   0x00080000\0" \
+	"nand_u-boot_addr=0x00080000\0" \
+	"nand_u-boot_size=0x001e0000\0" \
+	"nand_param_addr= 0x00260000\0" \
+	"nand_param_size= 0x00020000\0" \
+	"nand_dtb_addr=   0x00280000\0" \
+	"nand_dtb_size=   0x00080000\0" \
+	"nand_kernel_addr=0x00300000\0" \
+	"nand_kernel_size=0x00500000\0" \
+	"nand_rootfs_addr=0x00800000\0" \
+	"nand_rootfs_size=0x0f800000\0" \
+	"updatepath=/batw-sw\0" \
+	"nand_args=setenv bootargs " \
+		"console=${console} " \
+		"vt.global_cursor_default=0 " \
+		"${mtd_parts} " \
+		"root=${nand_root} " \
+		"rootfstype=${nand_root_fs_type} " \
+		"rootwait " \
+		"consoleblank=0 " \
+		"; " \
+	"\0" \
+	"nand_boot=echo Booting from nand ...; " \
+		"run nand_args; " \
+		"nand read ${loadaddr} ${nand_kernel_addr} ${nand_kernel_size} || exit;" \
+		"nand read ${dtbaddr} ${nand_dtb_addr} ${nand_dtb_size} || exit; " \
+		"bootm ${loadaddr} - ${dtbaddr}; " \
+	"\0" \
+	"nand_update=echo Updating nand from mmc...; " \
+		"if size mmc 0 ${updatepath}; then " \
+			"if load mmc 0 ${loadaddr} ${updatepath}/MLO; then " \
+				"echo Found new SPL, flash it.; "\
+				"nand erase ${nand_spl_addr} ${nand_spl_size}; " \
+				"nand write ${loadaddr} ${nand_spl_addr} ${filesize}; " \
+			"fi; " \
+			"if load mmc 0 ${loadaddr} ${updatepath}/u-boot.img; then " \
+				"echo Found new U-Boot, flash it.; "\
+				"nand erase ${nand_u-boot_addr} ${nand_u-boot_size}; " \
+				"nand write ${loadaddr} ${nand_u-boot_addr} ${filesize}; " \
+			"fi; " \
+			"if load mmc 0 ${loadaddr} ${updatepath}/devtree.dtb; then " \
+				"echo Found new device tree, flash it.; "\
+				"nand erase ${nand_dtb_addr} ${nand_dtb_size}; " \
+				"nand write ${loadaddr} ${nand_dtb_addr} ${filesize}; " \
+			"fi; " \
+			"if load mmc 0 ${loadaddr} ${updatepath}/uImage; then " \
+				"echo Found new uImage, flash it.; "\
+				"nand erase ${nand_kernel_addr} ${nand_kernel_size}; " \
+				"nand write ${loadaddr} ${nand_kernel_addr} ${filesize}; " \
+			"fi; " \
+			"if load mmc 0 ${loadaddr} ${updatepath}/rootfs.jffs2; then " \
+				"echo Found new rootfs, flash it.; "\
+				"nand erase ${nand_rootfs_addr} ${nand_rootfs_size}; " \
+				"nand write ${loadaddr} ${nand_rootfs_addr} ${filesize}; " \
+			"fi; " \
+			"echo Flashing done. Remove SD card before power cycling.; " \
+		"else " \
+			"echo Update path ${updatepath} not found.; " \
+		"fi; " \
+	"\0"
+
+#endif
+
+#ifdef CONFIG_SPI_FLASH
+
+#ifndef CONFIG_SPL_BUILD
+# define CONFIG_DM_SPI_FLASH
+#endif
+
+/* SPI Nor Flash */
+#define CONFIG_SF_DEFAULT_SPEED		24000000
+/*
+ * Default to using SPI for environment for M25PE40.
+ * 0x000000 - 0x010000 : SPL (64KiB)
+ * 0x010000 - 0x060000 : U-Boot (320kiB)
+ * 0x060000 - 0x080000 : U-Boot Environment (128KiB)
+ */
+#ifdef CONFIG_SPI_BOOT
+/* SPL related */
+#define CONFIG_SPL_SPI_LOAD
+#define CONFIG_SYS_SPI_U_BOOT_OFFS	0x10000
+
+/* M25PE40: 64 KiB env size */
+#define CONFIG_ENV_SIZE			SZ_64K
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#define CONFIG_ENV_SECT_SIZE		SZ_64K
+#define CONFIG_ENV_OFFSET		(2112 * 1024)
+#define MTDIDS_DEFAULT			"nor0=m25pe40-flash.0"
+#define MTDPARTS_DEFAULT		"mtdparts=m25pe40-flash.0:64k(SPL)," \
+					"2048k(u-boot),64k(u-boot-env1)"
+#endif
+
+#define MMC_BOOT_ENV_SETTINGS \
+	"mlofilespi=MLO.byteswap\0" \
+	"ubootoffset=0x10000\0" \
+	"spiflashsize=0x1000000\0" \
+	"bootsize=0x210000\0" \
+	"emmc_root=/dev/mmcblk1p2\0" \
+	"emmc_args=setenv bootargs " \
+		"console=${console} " \
+		"vt.global_cursor_default=0 " \
+		"root=${emmc_root} " \
+		"rootwait " \
+		"consoleblank=0 " \
+		"; " \
+	"\0" \
+	"emmc_boot=echo Booting from Emmc ...; " \
+		"run emmc_args; " \
+		"load mmc 1:1 ${loadaddr} ${kernelfile} || exit; " \
+		"load mmc 1:1 ${dtbaddr} ${dtbfile} || exit; " \
+		"bootm ${loadaddr} - ${dtbaddr}; " \
+	"\0" \
+	"update_spiflash=echo Updating SPI Flash ...; " \
+		"sf probe 0; " \
+		"sf erase 0 +${bootsize}; " \
+		"mmc rescan; " \
+		"load mmc 0 ${loadaddr} ${mlofilespi} || exit; "\
+		"sf write ${loadaddr} 0 ${filesize}; " \
+		"load mmc 0 ${loadaddr} ${ubootfile} || exit; " \
+		"sf write ${loadaddr} ${ubootoffset} ${filesize}; " \
+	"\0"
+
+#endif
+
+#endif
-- 
2.11.0

